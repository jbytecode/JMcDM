var documenterSearchIndex = {"docs":
[{"location":"mcdms/#Multiple-Criteria-Decision-Making-Tools","page":"MCDM","title":"Multiple Criteria Decision Making Tools","text":"","category":"section"},{"location":"mcdms/#Copeland","page":"MCDM","title":"Copeland","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.copeland","category":"page"},{"location":"mcdms/#JMcDM.Copeland.copeland","page":"MCDM","title":"JMcDM.Copeland.copeland","text":"    copeland(ordering_mat)\n\nArguments\n\nordering_mat::Array{Int, 2}`: Ordering matrix.\n\nDescription\n\nThe function takes an ordering matrix as input. Different ordering results are in columns. Orderings are in ascending order. The function returns the ranks. The alternative with rank  1 is the winner. \n\nOutput\n\n::Array{Int, 1}: Vector of ranks.\n\n\n\n\n\nExample\n\njulia> using JMcDM\n\njulia> df = DataFrame(\n    :c1 => [1.0, 2, 3, 4],\n    :c2 => [5.0, 6, 7, 8],\n    :c3 => [10.0, 11, 12, 13],\n    :c4 => [20.0, 30, 40, 360],\n)\n\njulia> weights = [0.25, 0.25, 0.25, 0.25]\njulia> fns = [maximum, maximum, maximum, maximum]\n\njulia> met = [\n    PIVMethod(),\n    PSIMethod(),\n    ROVMethod(),\n    SawMethod(),\n    VikorMethod(),\n    WaspasMethod(),\n    WPMMethod(),\n]\n\njulia> result = copeland(Matrix(df), w, fns, met)\n\n4×8 DataFrame\n Row │ Piv    Psi    Rov    Saw    Vikor  Waspas  Wpm    Copeland \n     │ Int64  Int64  Int64  Int64  Int64  Int64   Int64  Int64    \n─────┼────────────────────────────────────────────────────────────\n   1 │     1      1      1      1      1       1      1         3\n   2 │     2      2      2      2      2       2      2         1\n   3 │     3      3      3      3      3       3      3        -1\n   4 │     4      4      4      4      4       4      4        -3\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#TOPSIS","page":"MCDM","title":"TOPSIS","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.topsis","category":"page"},{"location":"mcdms/#JMcDM.Topsis.topsis","page":"MCDM","title":"JMcDM.Topsis.topsis","text":"    topsis(decisionMat, weights, fns; normalization)\n\nApply TOPSIS (Technique for Order of Preference by Similarity to Ideal Solution) method  for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n candidate (or strategy) and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of function that are either minimize or maximize.\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\ntopsis() applies the TOPSIS method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.\n\nOutput\n\n::TopsisResult: TopsisResult object that holds multiple outputs including scores and best index.\n\nExamples\n\njulia> df = DataFrame();\njulia> df[:, :x] = Float64[9, 8, 7];\njulia> df[:, :y] = Float64[7, 7, 8];\njulia> df[:, :z] = Float64[6, 9, 6];\njulia> df[:, :q] = Float64[7, 6, 6];\n\njulia> w = Float64[4, 2, 6, 8];\n\njulia> df\n3×4 DataFrame\n Row │ x        y        z        q       \n     │ Float64  Float64  Float64  Float64 \n─────┼────────────────────────────────────\n   1 │     9.0      7.0      6.0      7.0\n   2 │     8.0      7.0      9.0      6.0\n   3 │     7.0      8.0      6.0      6.0\n\njulia> fns = [maximum, maximum, maximum, maximum];\njulia> result = topsis(Matrix(df), w, fns);\n\njulia> result.bestIndex\n2\n\njulia> result.scores\n3-element Array{Float64,1}:\n 0.38768695492211824\n 0.6503238218850163\n 0.08347670030339041\n\nReferences\n\nHwang, C.L.; Yoon, K. (1981). Multiple Attribute Decision Making: Methods and Applications. New York: Springer-Verlag\n\nCelikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018\n\nİşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8\n\n\n\n\n\n    topsis(setting)\n\nApply TOPSIS (Technique for Order of Preference by Similarity to Ideal Solution) method  for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\ntopsis() applies the TOPSIS method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.\n\nOutput\n\n::TopsisResult: TopsisResult object that holds multiple outputs including scores and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#ELECTRE","page":"MCDM","title":"ELECTRE","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.electre","category":"page"},{"location":"mcdms/#JMcDM.ELECTRE.electre","page":"MCDM","title":"JMcDM.ELECTRE.electre","text":"    electre(decisionMat, weights, fns; normalization)\n\nApply ELECTRE (ELimination Et Choice Translating REality) method  for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n candidate (or strategy) and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of function that are either minimize or maximize.\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\nelectre() applies the ELECTRE method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized. C and D values are used to determine the best strategy. If the strategy with the highest C value  is same as the strategy with the lowest D value than the solution is unique. Otherwise, two strategies  are reported as the solution. \n\nOutput\n\n::ElectreResult: ElectreResult object that holds multiple outputs including scores and best index.\n\nExamples\n\njulia> w =  [0.110, 0.035, 0.379, 0.384, 0.002, 0.002, 0.010, 0.077];\njulia> Amat = [\n      100 92 10 2 80 70 95 80 ;\n      80  70 8  4 100 80 80 90 ;\n      90 85 5 0 75 95 70 70 ; \n      70 88 20 18 60 90 95 85\n    ];\n\njulia> fns = [maximum for i in 1:8];\njulia> result = electre(Amat, w, fns)\n\n\njulia> result.bestIndex\n(4,)\n\njulia> result.C\n4-element Array{Float64,1}:\n  0.3693693693693696\n  0.01501501501501501\n -2.473473473473473\n  2.0890890890890894\n\njulia> result.D\n4-element Array{Float64,1}:\n  0.1914244325928971\n -0.19039293350192432\n  2.884307608766315\n -2.885339107857288\n\nReferences\n\nCelikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018\n\n\n\n\n\n    electre(setting)\n\nApply ELECTRE (ELimination Et Choice Translating REality) method  for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\nelectre() applies the ELECTRE method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized. C and D values are used to determine the best strategy. If the strategy with the highest C value  is same as the strategy with the lowest D value than the solution is unique. Otherwise, two strategies  are reported as the solution. \n\nOutput\n\n::ElectreResult: ElectreResult object that holds multiple outputs including scores and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#DEMATEL","page":"MCDM","title":"DEMATEL","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.dematel","category":"page"},{"location":"mcdms/#JMcDM.DEMATEL.dematel","page":"MCDM","title":"JMcDM.DEMATEL.dematel","text":"    dematel(comparisonMat; threshold = nothing)\n\nApply Dematel for a given comparison matrix.\n\nArguments:\n\ncomparisonMat::Matrix: n × n Matrix of input values where n is the number of criteria. Values are either 0, 1, 2, 3, or 4 which indicate the level of importance of the ith criterion relative to the jth criterion.\nthreshold::Union{Nothing, Float64}: Optional threshold used in calculating values of influence matrix. It is calculated when the argument is omitted. \n\nDescription\n\ndematel() applies the Dematel method to calculate criteria weights, possibly for use in another multi-criteria decision making tool.\n\nOutput\n\n::DematelResult: DematelResult object that holds many results including weights for each single criterion.\n\nExamples\n\njulia> K = [\n        0 3 0 2 0 0 0 0 3 0;\n        3 0 0 0 0 0 0 0 0 2;\n        4 1 0 2 1 3 1 2 3 2;\n        4 1 4 0 1 2 0 1 0 0;\n        3 2 3 1 0 3 0 2 0 0;\n        4 1 4 4 0 0 0 1 1 3;\n        3 0 0 0 0 2 0 0 0 0;\n        3 0 4 3 2 3 1 0 0 0;\n        4 3 2 0 0 1 0 0 0 2;\n        2 1 0 0 0 0 0 0 3 0\n    ];\n\njulia> result = dematel(K);\n\njulia> result.weights\n10-element Array{Float64,1}:\n 0.1686568559124561\n 0.07991375718719543\n 0.14006200243438863\n 0.10748052790517183\n 0.08789022388276985\n 0.12526272598854982\n 0.03067915023486491\n 0.10489168834828348\n 0.092654758940811\n 0.06250830916550884\n\nReferences\n\nCelikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#MOORA","page":"MCDM","title":"MOORA","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.moora","category":"page"},{"location":"mcdms/#JMcDM.MOORA.moora","page":"MCDM","title":"JMcDM.MOORA.moora","text":"    moora_ratio(decisionMat, weights, fns; method = :reference, normalization)\n\nApply MOORA (Multi-Objective Optimization By Ratio Analysis) method for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n candidate (or strategy) and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of function that are either maximum or minimum.\nmethod::Symbol: Either :reference or :ratio. By default, it is :reference.\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\nmoora() applies the MOORA method to rank n strategies subject to m criteria which are supposed to be  either maximized or minimized. This method has two different versions. The method parameter determines the method used. It is :reference by default. For the other version, it can be set to :ratio.  \n\nOutput\n\n::MooraResult: MooraResult object that holds multiple outputs including scores and best index.\n\nReferences\n\nKUNDAKCI, Nilsen. \"Combined multi-criteria decision making approach based on MACBETH  and MULTI-MOORA methods.\" Alphanumeric Journal 4.1 (2016): 17-26.\n\nCelikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018\n\nİşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8\n\n\n\n\n\n    moora(setting; method = :reference)\n\nApply MOORA (Multi-Objective Optimization By Ratio Analysis) method for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \nmethod::Symbol: Either :reference or :ratio. By default, it is :reference.\n\nDescription\n\nmoora() applies the MOORA method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.\n\nOutput\n\n::MooraResult: MooraResult object that holds multiple outputs including scores and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#VIKOR","page":"MCDM","title":"VIKOR","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.vikor","category":"page"},{"location":"mcdms/#JMcDM.VIKOR.vikor","page":"MCDM","title":"JMcDM.VIKOR.vikor","text":"    vikor(decisionMat, weights, fns; v = 0.5, normalization)\n\nApply VIKOR (VlseKriterijumska Optimizcija I Kaompromisno Resenje in Serbian) method for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n candidate (or strategy) and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of function that are either maximum or minimum.\nv::Float64: Optional algorithm parameter. Default is 0.5.\nnormalization{<:Function}: Optional normalization function. Default is Normalizations.inversemaxminrangenormalization.\n\nDescription\n\nvikor() applies the VIKOR method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.\n\nOutput\n\n::VikorResult: VikorResult object that holds multiple outputs including scores and best index.\n\nExamples\n\njulia> Amat = [\n             100 92 10 2 80 70 95 80 ;\n             80  70 8  4 100 80 80 90 ;\n             90 85 5 0 75 95 70 70 ; \n             70 88 20 18 60 90 95 85\n           ];\n\n\njulia> fns = [maximum, maximum, maximum, maximum, maximum, maximum, maximum, maximum];\n\njulia> result = vikor(Amat, w, fns);\n\njulia> result.scores\n4-element Array{Float64,1}:\n  0.7489877763052237\n  0.7332093914796731\n  1.0\n  0.0\n\njulia> result.bestIndex\n4\n\n\nReferences\n\nCelikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018\n\n\n\n\n\n    vikor(setting; v = 0.5)\n\nApply VIKOR (VlseKriterijumska Optimizcija I Kaompromisno Resenje in Serbian) method for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \nv::Float64: Optional algorithm parameter. Default is 0.5.\n\nDescription\n\nvikor() applies the VIKOR method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.\n\nOutput\n\n::VikorResult: VikorResult object that holds multiple outputs including scores and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#AHP","page":"MCDM","title":"AHP","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.ahp","category":"page"},{"location":"mcdms/#JMcDM.AHP.ahp","page":"MCDM","title":"JMcDM.AHP.ahp","text":"AHP(comparisonMatrixList, criteriaComparisonMatrix)\n\nApply AHP (Analytical Hierarchy Process) for a given list of comparison matrices and criteria comparison matrix.\n\nArguments:\n\ncomparisonMatrixList::Array{Matrix,1}: Array of comparison matrices for all of the criteria. \ncriteriaComparisonMatrix::Matrix: Criteria comparison matrix for AHP (Comparison of columns). \n\nDescription\n\nAHP is based on subjective comparison between criteria. The success of the method highly depends on  consistency of these comparison. The method test the consistency first. At the next step, weights are  calculated. The ordering of rows is determined by these weights.\n\nOutput\n\n::AHPResult: AhpResult object that holds multiple outputs including calculated weights and scores.\n\nExamples\n\njulia> K\n8×8 Array{Float64,2}:\n 1.0       7.0  0.2    0.125     0.5   0.333333  0.2       1.0\n 0.142857  1.0  0.125  0.111111  0.25  0.2       0.111111  0.125\n 5.0       8.0  1.0    0.333333  4.0   2.0       1.0       1.0\n 8.0       9.0  3.0    1.0       7.0   5.0       3.0       3.0\n 2.0       4.0  0.25   0.142857  1.0   0.5       0.2       0.2\n 3.0       5.0  0.5    0.2       2.0   1.0       0.333333  0.333333\n 5.0       9.0  1.0    0.333333  5.0   3.0       1.0       1.0\n 1.0       8.0  1.0    0.333333  5.0   3.0       1.0       1.0\n\njulia> A1\n4×4 Array{Float64,2}:\n 1.0       3.0  0.2       2.0\n 0.333333  1.0  0.142857  0.333333\n 5.0       7.0  1.0       4.0\n 0.5       3.0  0.25      1.0\n\njulia> A2\n4×4 Array{Float64,2}:\n 1.0   0.5       4.0       5.0\n 2.0   1.0       6.0       7.0\n 0.25  0.166667  1.0       3.0\n 0.2   0.142857  0.333333  1.0\n\njulia> A3\n4×4 Array{Float64,2}:\n 1.0       0.5  0.166667  3.0\n 2.0       1.0  0.25      5.0\n 6.0       4.0  1.0       9.0\n 0.333333  0.2  0.111111  1.0\n\njulia> A4\n4×4 Array{Float64,2}:\n 1.0       7.0  0.25      2.0\n 0.142857  1.0  0.111111  0.2\n 4.0       9.0  1.0       5.0\n 0.5       5.0  0.2       1.0\n\njulia> A5\n4×4 Array{Float64,2}:\n 1.0       6.0  2.0   3.0\n 0.166667  1.0  0.25  0.333333\n 0.5       4.0  1.0   2.0\n 0.333333  3.0  0.5   1.0\n\njulia> A6\n4×4 Array{Float64,2}:\n 1.0  0.25  0.5  0.142857\n 4.0  1.0   2.0  0.333333\n 2.0  0.5   1.0  0.2\n 7.0  3.0   5.0  1.0\n\njulia> A7\n4×4 Array{Float64,2}:\n 1.0       3.0   7.0  1.0\n 0.333333  1.0   4.0  0.333333\n 0.142857  0.25  1.0  0.142857\n 1.0       3.0   7.0  1.0\n\njulia> A8\n4×4 Array{Float64,2}:\n 1.0    2.0       5.0       8.0\n 0.5    1.0       3.0       6.0\n 0.2    0.333333  1.0       3.0\n 0.125  0.166667  0.333333  1.0\n\njulia> as = hcat(A1, A2, A3, A4, A5, A6, A7, A8);\njulia> result = ahp(as, K);\njulia> result.bestIndex\n3\njulia> result.scores\n4-element Array{Float64,1}:\n 0.2801050163111839\n 0.14822726478768022\n 0.3813036392434616\n 0.19036407965767424\n\nReferences\n\nSaaty, Thomas L. \"Decision making with the analytic hierarchy process.\" International journal of services sciences 1.1 (2008): 83-98.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#Grey-Relational-Analysis","page":"MCDM","title":"Grey Relational Analysis","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.grey","category":"page"},{"location":"mcdms/#JMcDM.GREY.grey","page":"MCDM","title":"JMcDM.GREY.grey","text":"    grey(decisionMat, weights, fs; zeta, normalization)\n\nPerform GRA (Grey Relational Analysis) for a given decision matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of decision matrix in type of DataFrame. \nweights::Array{Float64, 1}: m-vector of weights for criteria.\nfs::Array{Function, 1}: m-vector of functions that are either maximize or minimize for each single criterion.\nzeta::Float64: zeta parameter for the algorithm. The default is 0.5.\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\nApplies GRA (Grey Relational Analysis).\n\nOutput\n\n::GreyResult: GreyResult object that holds many values including ordering of strategies or candidates and best index.\n\nExamples\n\njulia> # Decision matrix of 5 candidates and 6 criteria.\njulia> df = DataFrame(\n               :K1 => [105000.0, 120000, 150000, 115000, 135000],\n               :K2 => [105.0, 110, 120, 105, 115],\n               :K3 => [10.0, 15, 12, 20, 15],\n               :K4 => [4.0, 4, 3, 4, 5],\n               :K5 => [300.0, 500, 550, 600, 400],\n               :K6 => [10.0, 8, 12, 9, 9]\n        )\n5×6 DataFrame\n Row │ K1        K2       K3       K4       K5       K6      \n     │ Float64   Float64  Float64  Float64  Float64  Float64 \n─────┼───────────────────────────────────────────────────────\n   1 │ 105000.0    105.0     10.0      4.0    300.0     10.0\n   2 │ 120000.0    110.0     15.0      4.0    500.0      8.0\n   3 │ 150000.0    120.0     12.0      3.0    550.0     12.0\n   4 │ 115000.0    105.0     20.0      4.0    600.0      9.0\n   5 │ 135000.0    115.0     15.0      5.0    400.0      9.0\n\njulia> # Direction of optimization for each single criterion\njulia> functionlist = [minimum, maximum, minimum, maximum, maximum, minimum];\n\njulia> # Weights\njulia> w = [0.05, 0.20, 0.10, 0.15, 0.10, 0.40];\n\njulia> result = grey(Matrix(df), w, functionlist);\n\njulia> result.scores\n5-element Array{Float64,1}:\n 0.525\n 0.7007142857142857\n 0.5464285714285715\n 0.5762820512820512\n 0.650952380952381\n\njulia> result.bestIndex\n2\n\nReferences\n\nİşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8\n\n\n\n\n\n    grey(setting; zeta)\n\nPerform GRA (Grey Relational Analysis) for a given decision matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \nzeta::Float64: zeta parameter for the algorithm. The default is 0.5.\n\nDescription\n\nApplies GRA (Grey Relational Analysis).\n\nOutput\n\n::GreyResult: GreyResult object that holds many values including ordering of strategies or candidates and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#Non-dominated-Sorting","page":"MCDM","title":"Non-dominated Sorting","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.nds","category":"page"},{"location":"mcdms/#JMcDM.NDS.nds","page":"MCDM","title":"JMcDM.NDS.nds","text":"nds(data, fns)\n\nSort multidimensional data using non-dominated sorting algorithm.\n\nArguments\n\ndata::Matrix: n x k desicion matrix with n cases and k criteria.\nfns::Array{<:Function, 1}: Vector of functions with elements of maximum or minimum.\n\nOutput\n\n::NDSResult: NDSResult object that holds multiple outputs including ranks and best index.\n\nExamples\n\n julia> cases = [\n               1.0 2.0 3.0;\n               2.0 1.0 3.0;\n               1.0 3.0 2.0;\n               4.0 5.0 6.0\n           ];\n\n\njulia> result = nds(cases, [maximum, maximum, maximum]);\n\njulia> result.ranks\n4-element Array{Int64,1}:\n 0\n 0\n 0\n 3\n\njulia> result.bestIndex\n4 \n\nReferences\n\nDeb, Kalyanmoy, et al. \"A fast elitist non-dominated sorting genetic algorithm for multi-objective optimization: NSGA-II.\"  International conference on parallel problem solving from nature. Springer, Berlin, Heidelberg, 2000.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#SAW","page":"MCDM","title":"SAW","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.saw","category":"page"},{"location":"mcdms/#JMcDM.SAW.saw","page":"MCDM","title":"JMcDM.SAW.saw","text":"    saw(decisionMat, weights, fns; normalization)\n\nApply SAW (Simple Additive Weighting) method for a given matrix and weights. This method also known as WSM (Weighted Sum Model)\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n candidate (or strategy) and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns. \nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\nsaw() applies the SAW method to rank n strategies subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::SawResult: SawResult object that holds multiple outputs including scores, rankings, and best index.\n\nExamples\n\njulia> decmat = [4.0  7  3  2  2  2  2;\n                 4.0  4  6  4  4  3  7;\n                 7.0  6  4  2  5  5  3;\n                 3.0  2  5  3  3  2  5;\n                 4.0  2  2  5  5  3  6];\n\njulia> fns = [maximum for i in 1:7];\n\njulia> weights = [0.283, 0.162, 0.162, 0.07, 0.085, 0.162, 0.076];\n\njulia> result = saw(decmat, weights, fns);\n\njulia> result.scores\n5-element Array{Float64,1}:\n 0.5532285714285714\n 0.7134857142857142\n 0.8374285714285714\n 0.5146571428571429\n 0.5793428571428572\n\njulia> result.bestIndex\n3\n\nReferences\n\nAfshari, Alireza, Majid Mojahed, and Rosnah Mohd Yusuff. \"Simple additive weighting approach to  personnel selection problem.\" International Journal of Innovation, Management and Technology  1.5 (2010): 511.\n\n\n\n\n\n    saw(setting)\n\nApply SAW (Simple Additive Weighting) method for a given matrix and weights. This method also known as WSM (Weighted Sum Model)\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\nsaw() applies the SAW method to rank n strategies subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::SawResult: SawResult object that holds multiple outputs including scores, rankings, and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#ARAS","page":"MCDM","title":"ARAS","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.aras","category":"page"},{"location":"mcdms/#JMcDM.ARAS.aras","page":"MCDM","title":"JMcDM.ARAS.aras","text":"aras(decisionMat, weights, fs; normalization)\n\nApply ARAS (Additive Ratio ASsessment) method for a given matrix, weights and, type of criteria.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alternatives and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfs::Array{<:Function,1}: m-vector of type of criteria. The benefit criteria shown with \"maximum\", and the cost criteria shown with \"minimum\".\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\naras() applies the ARAS method to rank n alternatives subject to m criteria and criteria type vector.\n\nOutput\n\n::ARASResult: ARASResult object that holds multiple outputs including scores and best index.\n\nExamples\n\njulia> df = DataFrame(\n    :K1 => [105000.0, 120000, 150000, 115000, 135000],\n    :K2 => [105.0, 110, 120, 105, 115],\n    :K3 => [10.0, 15, 12, 20, 15],\n    :K4 => [4.0, 4, 3, 4, 5],\n    :K5 => [300.0, 500, 550, 600, 400],\n    :K6 => [10.0, 8, 12, 9, 9]\n)\njulia> df\n5×6 DataFrame\n Row │ K1        K2       K3       K4       K5       K6      \n     │ Float64   Float64  Float64  Float64  Float64  Float64 \n─────┼───────────────────────────────────────────────────────\n   1 │ 105000.0    105.0     10.0      4.0    300.0     10.0\n   2 │ 120000.0    110.0     15.0      4.0    500.0      8.0\n   3 │ 150000.0    120.0     12.0      3.0    550.0     12.0\n   4 │ 115000.0    105.0     20.0      4.0    600.0      9.0\n   5 │ 135000.0    115.0     15.0      5.0    400.0      9.0\n\njulia> result = aras(Matrix(df), w, fs);\njulia> result.bestIndex\n2\njulia> result.scores\n5-element Array{Float64,1}:\n 0.8142406768388222\n 0.8928861957614441\n 0.764157900073527\n 0.8422546181927358\n 0.8654063509472654\n\nReferences\n\nZavadskas, E. K., & Turskis, Z. (2010). A new additive ratio assessment (ARAS) method in multicriteria decision‐making. Technological and Economic Development of Economy, 16(2), 159-172. Yıldırım, B. F. (2015). \"Çok Kriterli Karar Verme Problemlerinde ARAS Yöntemi\". Kafkas Üniversitesi İktisadi ve İdari Bilimler Fakültesi Dergisi, 6 (9), 285-296. http://dx.doi.org/10.18025/kauiibf.65151\n\n\n\n\n\naras(setting)\n\nApply ARAS (Additive Ratio ASsessment) method for a given matrix, weights and, type of criteria.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\naras() applies the ARAS method to rank n alternatives subject to m criteria and criteria type vector.\n\nOutput\n\n::ARASResult: ARASResult object that holds multiple outputs including scores and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#WPM","page":"MCDM","title":"WPM","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.wpm","category":"page"},{"location":"mcdms/#JMcDM.WPM.wpm","page":"MCDM","title":"JMcDM.WPM.wpm","text":"    wpm(decisionMat, weights, fns)\n\nApply WPM (Weighted Product Method) for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alterntives and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns. \nnormalization{<:Function}: Optional normalization function. \n\nDescription\n\nwpm() applies the WPM method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::WPMResult: WPMResult object that holds multiple outputs including scores, rankings, and best index.\n\nExamples\n\njulia> decmat = [3        12.5        2        120        14        3;\n       5        15        3        110        38        4;\n       3        13        2        120        19        3;\n       4        14        2        100        31        4;\n       3        15        1.5        125        40        4]\n5×6 Array{Float64,2}:\n 3.0  12.5  2.0  120.0  14.0  3.0\n 5.0  15.0  3.0  110.0  38.0  4.0\n 3.0  13.0  2.0  120.0  19.0  3.0\n 4.0  14.0  2.0  100.0  31.0  4.0\n 3.0  15.0  1.5  125.0  40.0  4.0\n\n\njulia> weights = [0.221, 0.159, 0.175, 0.127, 0.117, 0.201];\n\njulia> fns = [maximum, minimum, minimum, maximum, minimum, maximum];\n\njulia> result = wpm(decmat, weights, fns);\n\njulia> result.scores\n5-element Array{Float64,1}:\n 0.7975224331331252\n 0.7532541470584717\n 0.7647463553356331\n 0.7873956894790834\n 0.7674278741781709\n\njulia> result.bestIndex\n1\n\nReferences\n\nZavadskas, E. K., Turskis, Z., Antucheviciene, J., & Zakarevicius, A. (2012). Optimization of Weighted Aggregated Sum Product Assessment. Elektronika Ir Elektrotechnika, 122(6), 3-6. https://doi.org/10.5755/j01.eee.122.6.1810\n\n\n\n\n\n    wpm(setting)\n\nApply WPM (Weighted Product Method) for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\nwpm() applies the WPM method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::WPMResult: WPMResult object that holds multiple outputs including scores, rankings, and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#WASPAS","page":"MCDM","title":"WASPAS","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.waspas","category":"page"},{"location":"mcdms/#JMcDM.WASPAS.waspas","page":"MCDM","title":"JMcDM.WASPAS.waspas","text":"    waspas(decisionMat, weights, fns; lambda = 0.5, normalization)\n\nApply WASPAS (Weighted Aggregated Sum Product ASsessment ) for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alterntives and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns.\nlambda::Float64: joint criterion. 0<=lambda<=1, default=0.5.\nnormalization{<:Function}: Normalization function. Default is Normalizations.dividebycolumnmaxminnormalization.\n\nDescription\n\nwaspas() applies the WASPAS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::WASPASResult: WASPASResult object that holds multiple outputs including scores, rankings, and best index.\n\nExamples\n\njulia> decmat = [3        12.5        2        120        14        3;\n       5        15        3        110        38        4;\n       3        13        2        120        19        3;\n       4        14        2        100        31        4;\n       3        15        1.5        125        40        4]\n5×6 Array{Float64,2}:\n 3.0  12.5  2.0  120.0  14.0  3.0\n 5.0  15.0  3.0  110.0  38.0  4.0\n 3.0  13.0  2.0  120.0  19.0  3.0\n 4.0  14.0  2.0  100.0  31.0  4.0\n 3.0  15.0  1.5  125.0  40.0  4.0\n\n\njulia> weights = [0.221, 0.159, 0.175, 0.127, 0.117, 0.201];\n\njulia> fns = [maximum, minimum, minimum, maximum, minimum, maximum];\n\njulia> lambda = 0.5;\n\njulia> result = wpm(decmat, weights, fns, lambda);\n\njulia> result.scores\n5-element Array{Float64,1}:\n 0.8050212165665626\n 0.7750597051081832\n 0.770180748518019\n 0.7964243424353943\n 0.7882389370890854\n\n julia> result.bestIndex\n 1\n\nReferences\n\nZavadskas, E. K., Turskis, Z., Antucheviciene, J., & Zakarevicius, A. (2012). Optimization of Weighted Aggregated Sum Product Assessment. Elektronika Ir Elektrotechnika, 122(6), 3-6. https://doi.org/10.5755/j01.eee.122.6.1810 Aytaç Adalı, E. & Tuş Işık, A.. (2017). Bir Tedarikçi Seçim Problemi İçin SWARA ve WASPAS Yöntemlerine Dayanan Karar Verme Yaklaşımı. International Review of Economics and Management, 5 (4) , 56-77. DOI: 10.18825/iremjournal.335408\n\n\n\n\n\n    waspas(setting; lambda = 0.5)\n\nApply WASPAS (Weighted Aggregated Sum Product ASsessment ) for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \nlambda::Float64: joint criterion. 0<=lambda<=1, default=0.5.\n\nDescription\n\nwaspas() applies the WASPAS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::WASPASResult: WASPASResult object that holds multiple outputs including scores, rankings, and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#EDAS","page":"MCDM","title":"EDAS","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.edas","category":"page"},{"location":"mcdms/#JMcDM.EDAS.edas","page":"MCDM","title":"JMcDM.EDAS.edas","text":"    edas(decisionMat, weights, fns)\n\nApply EDAS (Evaluation based on Distance from Average Solution) for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alterntives and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns. \n\nDescription\n\nedas() applies the EDAS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::EDASResult: EDASResult object that holds multiple outputs including scores, rankings, and best index.\n\nExamples\n\njulia> decmat = [5000 5 5300 450;\n       4500 5 5000 400;\n       4500 4 4700 400;\n       4000 4 4200 400;\n       5000 4 7100 500;\n       5000 5 5400 450;\n       5500 5 6200 500;\n       5000 4 5800 450]\n8×4 Array{Int64,2}:\n 5000  5  5300  450\n 4500  5  5000  400\n 4500  4  4700  400\n 4000  4  4200  400\n 5000  4  7100  500\n 5000  5  5400  450\n 5500  5  6200  500\n 5000  4  5800  450\n\n\njulia> weights = [0.25, 0.25, 0.25, 0.25];\n\njulia> fns = [maximum, maximum, minimum, minimum];\n\njulia> result = edas(decmat, weights, fns);\n\njulia> result.scores\n8-element Array{Float64,1}:\n 0.7595941163602383\n 0.8860162461306114\n 0.6974721951442592\n 0.739657763190231\n 0.05908329207449442\n 0.7318326305342363\n 0.6416913873322523\n 0.38519414045559647\n\njulia> result.bestIndex\n2\n\nReferences\n\nKeshavarz Ghorabaee, M., Zavadskas, E. K., Olfat, L., & Turskis, Z. (2015). Multi-criteria inventory classification using a new method of evaluation based on distance from average solution (EDAS). Informatica, 26(3), 435-451.\n\nUlutaş, A. (2017). EDAS Yöntemi Kullanılarak Bir Tekstil Atölyesi İçin Dikiş Makinesi Seçimi. İşletme Araştırmaları Dergisi, 9(2), 169-183.\n\n\n\n\n\n    edas(setting)\n\nApply EDAS (Evaluation based on Distance from Average Solution) for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\nedas() applies the EDAS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::EDASResult: EDASResult object that holds multiple outputs including scores, rankings, and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#MARCOS","page":"MCDM","title":"MARCOS","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.marcos","category":"page"},{"location":"mcdms/#JMcDM.MARCOS.marcos","page":"MCDM","title":"JMcDM.MARCOS.marcos","text":"    marcos(decisionMat, weights, fns)\n\nApply MARCOS (Measurement Alternatives and Ranking according to COmpromise Solution) for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alterntives and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns. \n\nDescription\n\nmarcos() applies the MARCOS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::MARCOSResult: MARCOSResult object that holds multiple outputs including scores, rankings, and best index.\n\nExamples\n\njulia> decmat = [8.675 8.433 8.000 7.800 8.025 8.043;\n       8.825 8.600 7.420 7.463 7.825 8.229;\n       8.325 7.600 8.040 7.700 7.925 7.600;\n       8.525 8.667 7.180 7.375 7.750 8.071]\n4×6 Array{Float64,2}:\n 8.675  8.433  8.0   7.8    8.025  8.043\n 8.825  8.6    7.42  7.463  7.825  8.229\n 8.325  7.6    8.04  7.7    7.925  7.6\n 8.525  8.667  7.18  7.375  7.75   8.071\n\n\njulia> weights = [0.1901901901901902 , 0.15915915915915918 , 0.19819819819819823, 0.1901901901901902, 0.15115115115115116, 0.11111111111111112];\n\njulia> fns = [maximum, maximum, maximum, maximum, maximum, maximum];\n\njulia> result = marcos(decmat, weights, fns);\n\njulia> result.scores\n4-element Array{Float64,1}:\n 0.6848657890705123\n 0.6727670074308345\n 0.6625969531206817\n 0.6611030275027843\n\njulia> result.bestIndex\n1\n\nReferences\n\nStević, Z., Pamučar, D., Puška, A., Chatterjee, P., Sustainable supplier selection in healthcare industries using a new MCDM method: Measurement Alternatives and Ranking according to COmpromise Solution (MARCOS), Computers & Industrial Engineering (2019), doi: https://doi.org/10.1016/j.cie.2019.106231\n\nPuška, A., Stojanović, I., Maksimović, A., & Osmanović, N. (2020). Evaluation software of project management used measurement of alternatives and ranking according to compromise solution (MARCOS) method. Operational Research in Engineering Sciences: Theory and Applications, 3(1), 89-102.\n\n\n\n\n\n    marcos(setting)\n\nApply MARCOS (Measurement Alternatives and Ranking according to COmpromise Solution) for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting \n\nDescription\n\nmarcos() applies the MARCOS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::MARCOSResult: MARCOSResult object that holds multiple outputs including scores, rankings, and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#MABAC","page":"MCDM","title":"MABAC","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.mabac","category":"page"},{"location":"mcdms/#JMcDM.MABAC.mabac","page":"MCDM","title":"JMcDM.MABAC.mabac","text":"    mabac(decisionMat, weights, fns; normalization)\n\nApply MABAC (Multi-Attributive Border Approximation area Comparison) for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alternatives and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns. \nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\nmabac() applies the MABAC method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::MABACResult: MABACResult object that holds multiple outputs including scores, rankings, and best index.\n\nExamples\n\njulia> decmat = [2 1 4 7 6 6 7 3000;\n       4 1 5 6 7 7 6 3500;\n       3 2 6 6 5 6 8 4000;\n       5 1 5 7 6 7 7 3000;\n       4 2 5 6 7 7 6 3000;\n       3 2 6 6 6 6 6 3500]\n6×8 \nArray{Int64,2}:\n 2  1  4  7  6  6  7  3000\n 4  1  5  6  7  7  6  3500\n 3  2  6  6  5  6  8  4000\n 5  1  5  7  6  7  7  3000\n 4  2  5  6  7  7  6  3000\n 3  2  6  6  6  6  6  3500\n\n\njulia> weights = [0.293, 0.427, 0.067, 0.027, 0.053, 0.027, 0.053, 0.053];\n\njulia> fns = [maximum, maximum, maximum, maximum, maximum, maximum, maximum, minimum];\n\njulia> result = mabac(decmat, weights, fns);\n\njulia> result.scores\n6-element Array{Float64,1}:\n -0.3113160790692055\n -0.10898274573587217\n  0.2003505875974611\n  0.0421839209307945\n  0.3445172542641278\n  0.2003505875974611\n\njulia> result.bestIndex\n5\n\nReferences\n\nPamučar, D., & Ćirović, G. (2015). The selection of transport and handling resources in logistics centers using Multi-Attributive Border Approximation area Comparison (MABAC). Expert Systems with Applications, 42(6), 3016–3028. doi:10.1016/j.eswa.2014.11.057\n\nUlutaş, A. (2019). Entropi ve MABAC yöntemleri ile personel seçimi. OPUS–International Journal of Society Researches, 13(19), 1552-1573. DOI: 10.26466/opus.580456\n\n\n\n\n\n    mabac(setting)\n\nApply MABAC (Multi-Attributive Border Approximation area Comparison) for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\nmabac() applies the MABAC method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::MABACResult: MABACResult object that holds multiple outputs including scores, rankings, and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#MAIRCA","page":"MCDM","title":"MAIRCA","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.mairca","category":"page"},{"location":"mcdms/#JMcDM.MAIRCA.mairca","page":"MCDM","title":"JMcDM.MAIRCA.mairca","text":"    mairca(decisionMat, weights, fns; normalization)\n\nApply MAIRCA (Multi Attributive Ideal-Real Comparative Analysis) for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alternatives and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns. \nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\nmairca() applies the MAIRCA method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::MAIRCAResult: MAIRCAResult object that holds multiple outputs including scores, rankings, and best index.\n\nExamples\n\njulia> decmat = [6.952 8.000 6.649 7.268 8.000 7.652 6.316;\n       7.319 7.319 6.604 7.319 8.000 7.652 5.313;\n       7.000 7.319 7.652 6.952 7.652 6.952 4.642;\n       7.319 6.952 6.649 7.319 7.652 6.649 5.000]\n4×7 Array{Float64,2}:\n 6.952  8.0    6.649  7.268  8.0    7.652  6.316\n 7.319  7.319  6.604  7.319  8.0    7.652  5.313\n 7.0    7.319  7.652  6.952  7.652  6.952  4.642\n 7.319  6.952  6.649  7.319  7.652  6.649  5.0\n\n\njulia> weights = [0.172, 0.165, 0.159, 0.129, 0.112, 0.122, 0.140];\n\njulia> fns = [maximum, maximum, maximum, maximum, maximum, maximum, minimum];\n\njulia> result = mairca(decmat, weights, fns);\n\njulia> result.scores\n4-element Array{Float64,1}:\n 0.12064543054088471\n 0.08066456363291889\n 0.14586265389012484\n 0.14542366685864686\n\njulia> result.bestIndex\n2\n\nReferences\n\nPamučar, D., Lukovac, V., Božanić, D., & Komazec, N. (2018). Multi-criteria FUCOM-MAIRCA model for the evaluation of level crossings: case study in the Republic of Serbia. Operational Research in Engineering Sciences: Theory and Applications, 1(1), 108-129.\n\nUlutaş A.(2019),Swara Ve Mairca Yöntemleri İle Catering Firması Seçimi,BMIJ, (2019), 7(4): 1467-1479 http://dx.doi.org/10.15295/bmij.v7i4.1166\n\n\n\n\n\n    mairca(setting)\n\nApply MAIRCA (Multi Attributive Ideal-Real Comparative Analysis) for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\nmairca() applies the MAIRCA method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::MAIRCAResult: MAIRCAResult object that holds multiple outputs including scores, rankings, and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#COPRAS","page":"MCDM","title":"COPRAS","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.copras","category":"page"},{"location":"mcdms/#JMcDM.COPRAS.copras","page":"MCDM","title":"JMcDM.COPRAS.copras","text":"copras(decisionMat, weights, fs; normalization)\n\nApply COPRAS (COmplex PRoportional ASsesment) method for a given matrix, weights and, type of criteria.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alternatives and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfs::Array{<:Function,1}: m-vector of type of criteria. The benefit criteria shown with \"maximum\", and the cost criteria shown with \"minimum\".\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\ncopras() applies the COPRAS method to rank n alternatives subject to m criteria and criteria type vector.\n\nOutput\n\n::COPRASResult: COPRASResult object that holds multiple outputs including scores and best index.\n\nExamples\n\njulia> decmat = [2.50 240 57 45 1.10 0.333333;\n       2.50 285 60 75 4.00 0.428571;\n       4.50 320 100 65 7.50 1.111111;\n       4.50 365 100 90 7.50 1.111111;\n       5.00 400 100 90 11.00 1.111111;\n       2.50 225 60 45 1.10 0.333333;\n       2.50 270 57 60 4.00 0.428571;\n       4.50 330 100 70 7.50 1.111111;\n       4.50 365 100 80 7.50 1.111111;\n       5.00 380 110 65 8.00 1.111111;\n       2.50 285 65 80 4.00 0.400000;\n       4.00 280 75 65 4.00 0.400000;\n       4.50 365 102 95 7.50 1.111111;\n       4.50 400 102 95 7.50 1.111111;\n       6.00 450 110 95 11.00 1.176471;\n       6.00 510 110 105 11.00 1.176471;\n       6.00 330 140 110 18.50 1.395349;\n       2.50 240 65 80 4.00 0.400000;\n       4.00 280 75 75 4.00 0.400000;\n       4.50 355 102 95 7.50 1.111111;\n       4.50 385 102 90 7.50 1.111111;\n       5.00 385 114 95 7.50 1.000000;\n       6.00 400 110 90 11.00 1.000000;\n       6.00 480 110 95 15.00 1.000000;\n       6.00 440 140 100 18.50 1.200000;\n       6.00 500 140 100 18.50 1.200000;\n       5.00 450 125 100 15.00 1.714286;\n       6.00 500 150 125 18.50 1.714286;\n       6.00 515 180 140 22.00 2.307692;\n       7.00 550 200 150 30.00 2.307692;\n       6.00 500 180 140 15.00 2.307692;\n       6.00 500 180 140 18.50 2.307692;\n       6.00 500 180 140 22.00 2.307692;\n       7.00 500 180 140 30.00 2.307692;\n       7.00 500 200 140 37.00 2.307692;\n       7.00 500 200 140 45.00 2.307692;\n       7.00 500 200 140 55.00 2.307692;\n       7.00 500 200 140 75.00 2.307692]\n38×6 Array{Float64,2}:\n 2.5  240.0   57.0   45.0   1.1  0.333333\n 2.5  285.0   60.0   75.0   4.0  0.428571\n 4.5  320.0  100.0   65.0   7.5  1.11111\n 4.5  365.0  100.0   90.0   7.5  1.11111\n 5.0  400.0  100.0   90.0  11.0  1.11111\n 2.5  225.0   60.0   45.0   1.1  0.333333\n 2.5  270.0   57.0   60.0   4.0  0.428571\n 4.5  330.0  100.0   70.0   7.5  1.11111\n 4.5  365.0  100.0   80.0   7.5  1.11111\n 5.0  380.0  110.0   65.0   8.0  1.11111\n 2.5  285.0   65.0   80.0   4.0  0.4\n ⋮                               ⋮\n 6.0  500.0  150.0  125.0  18.5  1.71429\n 6.0  515.0  180.0  140.0  22.0  2.30769\n 7.0  550.0  200.0  150.0  30.0  2.30769\n 6.0  500.0  180.0  140.0  15.0  2.30769\n 6.0  500.0  180.0  140.0  18.5  2.30769\n 6.0  500.0  180.0  140.0  22.0  2.30769\n 7.0  500.0  180.0  140.0  30.0  2.30769\n 7.0  500.0  200.0  140.0  37.0  2.30769\n 7.0  500.0  200.0  140.0  45.0  2.30769\n 7.0  500.0  200.0  140.0  55.0  2.30769\n 7.0  500.0  200.0  140.0  75.0  2.30769\n\njulia> weights = [0.1667, 0.1667, 0.1667, 0.1667, 0.1667, 0.1667];\n\njulia> fns = [maximum, maximum, maximum, maximum, maximum, minimum];\n\njulia> result = copras(decmat, w, fs);\n\njulia> result.bestIndex\n38\n\njulia> result.scores\n38-element Array{Float64,1}:\n 0.021727395411605937\n 0.019814414550092637\n 0.01789214190869233\n 0.01624057709923278\n 0.01507318798582843\n 0.021837811311495522\n 0.020735423365838293\n 0.01754833367014725\n 0.016658288043259514\n 0.016258710042371068\n 0.019388734250223458\n ⋮\n 0.01064826476628102\n 0.01000964101170639\n 0.007056714858865703\n 0.010627520153194962\n 0.010419795157349462\n 0.010212070161503961\n 0.00876261130160425\n 0.007733739643860005\n 0.007258939653356005\n 0.006665439665226005\n 0.005478439688966004\n\nReferences\n\nKaklauskas, A., Zavadskas, E. K., Raslanas, S., Ginevicius, R., Komka, A., & Malinauskas, P. (2006). Selection of low-e windows in retrofit of public buildings by applying multiple criteria method COPRAS: A Lithuanian case. Energy and buildings, 38(5), 454-462. Özdağoğlu, A. (2013). İmalat işletmeleri için eksantrik pres alternatiflerinin COPRAS yöntemi ile karşılaştırılması. Gümüşhane Üniversitesi Sosyal Bilimler Enstitüsü Elektronik Dergisi, 4(8), 1-22. Yıldırım, B. F., Timor, M. (2019). \"Bulanık ve Gri COPRAS Yöntemleri Kullanılarak Tedarikçi Seçim Modeli Geliştirilmesi\". Optimum Ekonomi ve Yönetim Bilimleri Dergisi, 6 (2), 283-310.\n\n\n\n\n\ncopras(setting)\n\nApply COPRAS (COmplex PRoportional ASsesment) method for a given matrix, weights and, type of criteria.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\ncopras() applies the COPRAS method to rank n alternatives subject to m criteria and criteria type vector.\n\nOutput\n\n::COPRASResult: COPRASResult object that holds multiple outputs including scores and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#PROMETHEE","page":"MCDM","title":"PROMETHEE","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.promethee","category":"page"},{"location":"mcdms/#JMcDM.PROMETHEE.promethee","page":"MCDM","title":"JMcDM.PROMETHEE.promethee","text":"    promethee(decisionMatrix, weights, fns, prefs, qs, ps)\n\nApply PROMETHEE (Preference Ranking Organization METHod for Enrichment of Evaluations) method for a given matrix and weights.\n\nArguments:\n\ndecisionMatrix::Matrix: n × m matrix of objective values for n candidate (or strategy) and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of functions that are either maximum or minimum.\nprefs::Array{Function, 1}: m-vector of preference functions that are prometLinear, prometVShape, prometUShape, prometQuasi, or prometLevel.\nqs::Array{Float64, 1}: m-vector of q parameters that is used in corresponding preference function.\nps::Array{Float64, 1}: m-vector of p parameters that is used in corresponding preference function\n\nDescription\n\npromethee() applies the PROMETHEE method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.\n\nOutput\n\n::PrometheeResult: PrometheeResult object that holds multiple outputs including scores and best index.\n\nExamples\n\njulia> decmat = [42.0 35 43 51; \n                     89 72 92 85;\n                     14 85 17 40;\n                     57 60 45 80;\n                     48 32 43 40;\n                     71 45 60 85;\n                     69 40 72 55;\n                     64 35 70 60];\n\n\n\njulia> qs = [49, nothing, 45, 30];\n\njulia> ps = [100, 98, 95, 80];\n\njulia> weights = [0.25, 0.35, 0.22, 0.18];\n\njulia> fns = [maximum, maximum, maximum, maximum];\n\njulia> prefs = [prometLinear, prometVShape, prometLinear, prometLinear];\n\njulia> result = promethee(decmat, weights, fns, prefs, qs, ps);\n\njulia> result.scores\n8-element Array{Float64,1}:\n  0.0698938775510204\n -0.148590956382553\n -0.061361984793917565\n -0.04780408163265306\n  0.09859591836734694\n -0.0006389755902360891\n  0.03236974789915966\n  0.057536454581832736\n\njulia> result.bestIndex\n5\n\nReferences\n\nİşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8\n\n\n\n\n\n    promethee(setting, prefs, qs, ps)\n\nApply PROMETHEE (Preference Ranking Organization METHod for Enrichment of Evaluations) method for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \nprefs::Array{Function, 1}: m-vector of preference functions that are prometLinear, prometVShape, prometUShape, prometQuasi, or prometLevel.\nqs::Array{Float64, 1}: m-vector of q parameters that is used in corresponding preference function.\nps::Array{Float64, 1}: m-vector of p parameters that is used in corresponding preference function\n\nDescription\n\npromethee() applies the PROMETHEE method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.\n\nOutput\n\n::PrometheeResult: PrometheeResult object that holds multiple outputs including scores and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#CoCoSo","page":"MCDM","title":"CoCoSo","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.cocoso","category":"page"},{"location":"mcdms/#JMcDM.COCOSO.cocoso","page":"MCDM","title":"JMcDM.COCOSO.cocoso","text":"    cocoso(decisionMat, weights, fns; lambda, normalization)\n\nApply CoCoSo (Combined Compromise Solution) method for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alternatives and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns.\nlambda::Float64: joint criterion. 0<=lambda<=1, default=0.5.\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\ncocoso() applies the CoCoSo method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::CoCoSoResult: CoCoSoResult object that holds multiple outputs including scores, rankings, and best index.\n\nExamples\n\njulia> decmat = [3        12.5        2        120        14        3;\n       5        15        3        110        38        4;\n       3        13        2        120        19        3;\n       4        14        2        100        31        4;\n       3        15        1.5        125        40        4]\n5×6 Array{Float64,2}:\n 3.0  12.5  2.0  120.0  14.0  3.0\n 5.0  15.0  3.0  110.0  38.0  4.0\n 3.0  13.0  2.0  120.0  19.0  3.0\n 4.0  14.0  2.0  100.0  31.0  4.0\n 3.0  15.0  1.5  125.0  40.0  4.0\n\njulia> weights = [0.221, 0.159, 0.175, 0.127, 0.117, 0.201];\n\njulia> fns = [maximum, minimum, minimum, maximum, minimum, maximum];\n\njulia> lambda = 0.5;\n\njulia> result = cocoso(decmat, weights, fns, lambda);\n\njulia> result.scores\n7-element Array{Float64,1}:\n 2.0413128390265998\n 2.787989783418825\n 2.8823497955972495\n 2.4160457689259287\n 1.2986918936013303\n 1.4431429073391682\n 2.519094173200623\n\njulia> result.bestIndex\n3\n\nReferences\n\nYazdani, M., Zarate, P., Kazimieras Zavadskas, E. and Turskis, Z. (2019), \"A combined compromise solution (CoCoSo) method for multi-criteria decision-making problems\", Management Decision, Vol. 57 No. 9, pp. 2501-2519. https://doi.org/10.1108/MD-05-2017-0458\n\n\n\n\n\n    cocoso(setting; lambda)\n\nApply CoCoSo (Combined Compromise Solution) method for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object \nlambda::Float64: joint criterion. 0<=lambda<=1, default=0.5.\n\nDescription\n\ncocoso() applies the CoCoSo method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::CoCoSoResult: CoCoSoResult object that holds multiple outputs including scores, rankings, and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#Critic","page":"MCDM","title":"Critic","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.critic","category":"page"},{"location":"mcdms/#JMcDM.CRITIC.critic","page":"MCDM","title":"JMcDM.CRITIC.critic","text":"    critic(decisionMat, fns; normalization)\n\nApply CRITIC (Combined Compromise Solution) method for a given matrix and criteria types.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alternatives and m criteria \nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns.\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\ncritic() applies the CRITIC method to calculate weights using a decision matrix with   n alterntives subject to m criteria which are supposed to be either maximized or minimized.\n\nOutput\n\n::CRITICResult: CRITICResult object that holds multiple outputs including weighting and best index.\n\nExamples\n\n\njulia> decmat\n3×4 Array{Float64,2}:\n 12.9918  0.7264  -1.1009  1.59814\n  4.1201  5.8824   3.4483  1.02156\n  4.1039  0.0     -0.5076  0.984469\n\n\njulia> fns = [maximum, maximum, minimum, maximum];\n\njulia> result = critic(decmat, fns);\n\njulia> result.w\n4-element Array{Float64,1}:\n 0.16883905506169491\n 0.41844653698732126\n 0.24912338769165807\n 0.16359102025932576\n\n\nReferences\n\nDiakoulaki, D., Mavrotas, G., & Papayannakis, L. (1995). Determining objective weights in multiple criteria problems: The critic method. Computers & Operations Research, 22(7), 763–770. doi:10.1016/0305-0548(94)00059-h  Akçakanat, Ö., Aksoy, E., Teker, T. (2018). CRITIC ve MDL Temelli EDAS Yöntemi ile TR-61 Bölgesi Bankalarının Performans Değerlendirmesi. Süleyman Demirel Üniversitesi Sosyal Bilimler Enstitüsü Dergisi, 1 (32), 1-24.\n\n\n\n\n\n    critic(setting)\n\nApply CRITIC (Combined Compromise Solution) method for a given matrix and criteria types.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\ncritic() applies the CRITIC method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::CRITICResult: CRITICResult object that holds multiple outputs including weighting and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#CODAS","page":"MCDM","title":"CODAS","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.codas","category":"page"},{"location":"mcdms/#JMcDM.CODAS.codas","page":"MCDM","title":"JMcDM.CODAS.codas","text":"codas(decisionMat, weights, fs; normalization)\n\nApply CODAS (COmbinative Distance-based ASsessment) method for a given matrix, weights and, type of criteria.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alternatives and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfs::Array{<:Function,1}: m-vector of type of criteria. The benefit criteria shown with \"maximum\", and the cost criteria shown with \"minimum\".\ntau::Float64: tau parameter for the algorithm. The default is 0.02.\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\ncodas() applies the CODAS method to rank n alternatives subject to m criteria and criteria type vector.\n\nOutput\n\n::CODASResult: CODASResult object that holds multiple outputs including scores and best index.\n\nExamples\n\njulia> decmat\n7×5 Array{Float64,2}:\n 60.0   0.4   2540.0   500.0   990.0\n  6.35  0.15  1016.0  3000.0  1041.0\n  6.8   0.1   1727.2  1500.0  1676.0\n 10.0   0.2   1000.0  2000.0   965.0\n  2.5   0.1    560.0   500.0   915.0\n  4.5   0.08  1016.0   350.0   508.0\n  3.0   0.1   1778.0  1000.0   920.0\n\njulia> df = DataFrame(decmat)\n7×5 DataFrame\n Row │ x1       x2       x3       x4       x5      \n     │ Float64  Float64  Float64  Float64  Float64 \n─────┼─────────────────────────────────────────────\n   1 │   60.0      0.4    2540.0    500.0    990.0\n   2 │    6.35     0.15   1016.0   3000.0   1041.0\n   3 │    6.8      0.1    1727.2   1500.0   1676.0\n   4 │   10.0      0.2    1000.0   2000.0    965.0\n   5 │    2.5      0.1     560.0    500.0    915.0\n   6 │    4.5      0.08   1016.0    350.0    508.0\n   7 │    3.0      0.1    1778.0   1000.0    920.0\n\njulia> result = codas(Matrix(df), w, fs);\njulia> result.bestIndex\n2\njulia> result.scores\n7-element Array{Float64,1}:\n  0.5121764914884954\n  1.463300034504913\n  1.0715325899642418\n -0.21246799780012637\n -1.8515205523193041\n -1.1716767695713806\n  0.18865620373316055\n\n\nReferences\n\nKeshavarz Ghorabaee, M., Zavadskas, E. K., Turskis, Z., & Antucheviciene, J. (2016). A new combinative distance-based assessment (CODAS) method for multi-criteria decision-making. Economic Computation & Economic Cybernetics Studies & Research, 50(3), 25-44.\n\n\n\n\n\ncodas(setting; tau = 0.02)\n\nApply CODAS (COmbinative Distance-based ASsessment) method for a given matrix, weights and, type of criteria.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \ntau::Float64: tau parameter for the algorithm. The default is 0.02.\n\nDescription\n\ncodas() applies the CODAS method to rank n alternatives subject to m criteria and criteria type vector.\n\nOutput\n\n::CODASResult: CODASResult object that holds multiple outputs including scores and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#MEREC","page":"MCDM","title":"MEREC","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.merec","category":"page"},{"location":"mcdms/#JMcDM.MEREC.merec","page":"MCDM","title":"JMcDM.MEREC.merec","text":"merec(decisionMat, fns; normalization)\n\nApply MEREC (MEthod based on the Removal Effects of Criteria) for a given matrix and criteria types.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alternatives and m criteria \nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns.\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\nmerec() applies the MEREC method to calculate weights using a decision matrix with   n alternatives subject to m criteria which are supposed to be either maximized or minimized.\n\nOutput\n\n::MERECResult: MERECResult object that holds multiple outputs including weights.\n\nExamples\n\n\njulia> decisionMat = DataFrame(\n                   :K1 => [450, 10, 100, 220, 5],\n                   :K2 => [8000, 9100, 8200, 9300, 8400],\n                   :K3 => [54, 2, 31, 1, 23],\n                   :K4 => [145, 160, 153, 162, 158]\n               )\n5×4 DataFrame\n Row │ K1     K2     K3     K4    \n     │ Int64  Int64  Int64  Int64 \n─────┼────────────────────────────\n   1 │   450   8000     54    145\n   2 │    10   9100      2    160\n   3 │   100   8200     31    153\n   4 │   220   9300      1    162\n   5 │     5   8400     23    158\n\njulia> fs = [maximum, maximum, minimum, minimum];\n\njulia> result = merec(decisionMat, fs);\n\njulia> result.w\n4-element Vector{Float64}:\n 0.5752216672093823\n 0.01409659116846726\n 0.40156136388773117\n 0.009120377734419302\n\n\nReferences\n\nKeshavarz-Ghorabaee, M., Amiri, M., Zavadskas, E. K., Turskis, Z., & Antucheviciene, J. (2021). Determination of Objective Weights Using a New Method Based on the Removal Effects of Criteria (MEREC). Symmetry, 13(4), 525. https://doi.org/10.3390/sym13040525\n\n\n\n\n\n    merec(setting)\n\nApply MEREC (MEthod based on the Removal Effects of Criteria) for a given matrix and criteria types.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\nmerec() applies the MEREC method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::MERECResult: MERECResult object that holds multiple outputs including weighting and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#PIV","page":"MCDM","title":"PIV","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.piv","category":"page"},{"location":"mcdms/#JMcDM.PIV.piv","page":"MCDM","title":"JMcDM.PIV.piv","text":"piv(decisionMat, weights, fs; normalization)\n\nApply PIV (Proximity Indexed Value) method for a given matrix, weights and, type of criteria.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alternatives and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfs::Array{<:Function,1}: m-vector of type of criteria. The benefit criteria shown with \"maximum\", and the cost criteria shown with \"minimum\".\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\npiv() applies the PIV method to rank n alternatives subject to m criteria and criteria type vector. Alternatives  with lesser scores values (u_i values in the original article) are better as they represent the deviation  from the ideal values.\n\nOutput\n\n::PIVResult: PIVResult object that holds multiple outputs including scores, rankings, and best index.\n\nReferences\n\nSameera Mufazzal, S.M. Muzakkir, A new multi-criterion decision making (MCDM) method based on proximity indexed value for minimizing rank reversals, Computers & Industrial Engineering, Volume 119, 2018, Pages 427-438, ISSN 0360-8352, https://doi.org/10.1016/j.cie.2018.03.045.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#PSI","page":"MCDM","title":"PSI","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.psi","category":"page"},{"location":"mcdms/#JMcDM.PSI.psi","page":"MCDM","title":"JMcDM.PSI.psi","text":"    psi(decisionMat, fns; normalization)\n\nApply PSI (Preference Selection Index) method for a given matrix and directions of optimizations.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alterntives and m criteria \nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns.\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\npsi() applies the PSI method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::PSIResult: PSIResult object that holds multiple outputs including scores, rankings, and best index.\n\nExamples\n\njulia> decmat = [3        12.5        2        120        14        3;\n       5        15        3        110        38        4;\n       3        13        2        120        19        3;\n       4        14        2        100        31        4;\n       3        15        1.5        125        40        4]\n5×6 Array{Float64,2}:\n 3.0  12.5  2.0  120.0  14.0  3.0\n 5.0  15.0  3.0  110.0  38.0  4.0\n 3.0  13.0  2.0  120.0  19.0  3.0\n 4.0  14.0  2.0  100.0  31.0  4.0\n 3.0  15.0  1.5  125.0  40.0  4.0\n\n\n\njulia> fns = [maximum, minimum, minimum, maximum, minimum, maximum];\n\njulia> result = psi(decmat, fns)\nScores:\n[1.1252480520930113, 0.762593438114615, 1.1060476892230147, 1.0059872302387025, 0.7865885089329105]\nOrdering: (from worst to best)\n[2, 5, 4, 3, 1]\nBest indices:\n1\n\njulia> result.bestIndex \n1\n\nReferences\n\nManiya, Kalpesh, and Mangal Guido Bhatt. \"A selection of material using a novel type decision-making method:  Preference selection index method.\" Materials & Design 31.4 (2010): 1785-1789\n\n\n\n\n\n    psi(setting)\n\nApply PSI (Preference Selection Index) method for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\npsi() applies the PSI method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::PSIResult: PSIResult object that holds multiple outputs including scores, rankings, and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#ROV","page":"MCDM","title":"ROV","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.rov","category":"page"},{"location":"mcdms/#JMcDM.ROV.rov","page":"MCDM","title":"JMcDM.ROV.rov","text":"    rov(decisionMat, weights, fns; normalization)\n\nApply ROV (Range of Value) for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alternatives and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns (directions of optimization). \nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\nrov() applies the ROV method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::ROVResult: ROVResult object that holds multiple outputs including scores, rankings, and best index.\n\nExamples\n\njulia> mat = [\n        0.035 34.5 847 1.76 0.335 0.5 0.59 0.59\n        0.027 36.8 834 1.68 0.335 0.665 0.665 0.665\n        0.037 38.6 808 2.4 0.59 0.59 0.41 0.5\n        0.028 32.6 821 1.59 0.5 0.59 0.59 0.41];\n\n\njulia>  w = [0.3306, 0.0718, 0.1808, 0.0718, 0.0459, 0.126, 0.126, 0.0472];\n\njulia> fns = [minimum, minimum, minimum, minimum, maximum, minimum, minimum, maximum]\n\njulia> result = rov(mat, w, fns)\n\njulia> result.ranks \n\njulia> result.scores\n\nReferences\n\nMadić, Miloš et al. “Application of the ROV method for the selection of cutting fluids.”  Decision Science Letters 5 (2016): 245-254.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#MOOSRA","page":"MCDM","title":"MOOSRA","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.moosra","category":"page"},{"location":"mcdms/#JMcDM.MOOSRA.moosra","page":"MCDM","title":"JMcDM.MOOSRA.moosra","text":"    moosra(decisionMat, weights, fns; lambda = 0.5, normalization)\n\nApply MOOSRA (Multi-Objective Optimization on the basis of Simple Ratio Analysis) for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alterntives and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns.\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\nmoosra() applies the MOOSRA method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::MoosraResult: MoosraResult object that holds multiple outputs including scores, rankings, and best index.\n\nExamples\n\njulia> decmat = [3        12.5        2        120        14        3;\n       5        15        3        110        38        4;\n       3        13        2        120        19        3;\n       4        14        2        100        31        4;\n       3        15        1.5        125        40        4]\n5×6 Array{Float64,2}:\n 3.0  12.5  2.0  120.0  14.0  3.0\n 5.0  15.0  3.0  110.0  38.0  4.0\n 3.0  13.0  2.0  120.0  19.0  3.0\n 4.0  14.0  2.0  100.0  31.0  4.0\n 3.0  15.0  1.5  125.0  40.0  4.0\n\n\njulia> weights = [0.221, 0.159, 0.175, 0.127, 0.117, 0.201];\n\njulia> fns = [maximum, minimum, minimum, maximum, minimum, maximum];\n\njulia> result = moosra(decmat, weights, fns, lambda);\n\nReferences\n\nDas, Manik Chandra, Bijan Sarkar, and Siddhartha Ray. \"Decision making under conflicting environment: a new MCDM method.\"  International Journal of Applied Decision Sciences 5.2 (2012): 142-162.\n\n\n\n\n\n    moosra(setting)\n\nApply MOOSRA (Multi-Objective Optimization on the basis of Simple Ratio Analysis) for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\n\n\n\n\n","category":"function"},{"location":"mcdms/#SD","page":"MCDM","title":"SD","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.sd","category":"page"},{"location":"mcdms/#JMcDM.SD.sd","page":"MCDM","title":"JMcDM.SD.sd","text":"    sd(decisionMat, fns; normalization)\n\nApply SD method for a given matrix and directions of optimization.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alternatives and m criteria \nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns.\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\nsd() applies the SD method to calculate weights for a set of given criteria.\n\nOutput\n\n::SDResult: SDResult object that holds weights.\n\nReferences\n\nAYDIN, Yüksel. \"A hybrid multi-criteria decision making (MCDM) model consisting of SD and  COPRAS methods in performance evaluation of foreign deposit banks.\" Equinox Journal of  Economics Business and Political Studies 7.2 (2020): 160-176.\n\nDiakoulaki, Danae, George Mavrotas, and Lefteris Papayannakis. \"Determining objective weights  in multiple criteria problems: The critic method.\" Computers & Operations Research 22.7  (1995): 763-770.\n\n\n\n\n\n    sd(setting)\n\nApply SD method for a given matrix and criteria types.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\n\n\n\n\n","category":"function"},{"location":"mcdms/#SECA","page":"MCDM","title":"SECA","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.seca","category":"page"},{"location":"mcdms/#JMcDM.SECA.seca","page":"MCDM","title":"JMcDM.SECA.seca","text":"seca(decisionMat, fns:, beta; epsilon, normalization)\n\nImplement the SECA method for multi-criteria decision making.\n\nArguments\n\ndecisionMat::Matrix: A matrix of decision criteria.\nfns::Array{F,1}: A vector of functions that specifies the Beneficial Criteria (BC) as maximum and the non-Beneficial Criteria (NC) as minimum.\nbeta::Float64: This coefficient affects the importance of reaching the reference points of criteria weights. Note that the output of model is dependent on the value of beta. It's recommended to try several values untill you barely see any change in the weights of each criterion.\nepsilon::Float64 = 10^-3: a small positive parameter considered as a lower bound for criteria weights.\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\nseca implements the SECA method for multi-criteria decision making and finds the weights of the criteria simultaneously with evaluating the alternatives. The model is based on maximization of the overall performance of alternatives with consideration of the variation information of decision-matrix within and between criteria. seca returns a SecaResult object that contains the decision matrix, weights, scores, and ranks.\n\nReturns\n\nSECAResult: A SECAResult object that contains the decision matrix, weights, scores, and ranks.\n\nExample\n\njulia> using JuMP, Ipopt, JMcDM\njulia> mat = [\n           1.0     0.9925  0.9115  0.8     0.9401  1.0     0.9449;\n           0.8696  0.8271  0.8462  1.0     0.9181  0.978   1.0;\n           0.7391  0.8684  0.7615  0.2667  0.8177  0.8241  0.8305;\n           0.5217  0.7895  0.6654  0.2     0.8051  0.7236  0.8061;\n           0.6522  0.9135  0.7692  0.2857  0.8396  0.7063  0.8812;\n           0.6087  0.8346  0.7269  0.3077  0.8722  0.6742  0.8926;\n           0.913   0.985   0.9346  0.6667  0.9813  0.8641  0.9216;\n           0.8696  0.9624  1.0     0.5714  0.9632  0.7807  0.9751;\n           0.8261  1.0     0.8077  0.6667  1.0     0.7946  0.9104;\n           0.3478  0.8195  0.7462  0.3636  0.8263  0.6642  0.814\n       ];\n\njulia> fns = [maximum, minimum, minimum, minimum, minimum, minimum, minimum];\n\njulia> seca(mat, fns, 0.5)\nScores:\n[0.5495915719484191, 0.467758585220479, 0.7430581528101969, 0.805136683615562, 0.6786410609782462, 0.6314963009852793, 0.5445938440469921, 0.5570359821894877, 0.509907132860776, 0.4677585801615632]\nOrdering:\n[6, 9, 2, 1, 3, 4, 7, 5, 8, 10]\nBest indice:\n4\n\nReference\n\nSimultaneous Evaluation of Criteria and Alternatives (SECA) for Multi-Criteria Decision-Making\n\nwarning: Dependencies\nThis method is enabled when the JuMP and Ipopt packages are installed and loaded.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#LMAW","page":"MCDM","title":"LMAW","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.lmaw","category":"page"},{"location":"mcdms/#JMcDM.LMAW.lmaw","page":"MCDM","title":"JMcDM.LMAW.lmaw","text":"lmaw(decisionMat, weights, fns; normalization)\n\nApply LMAW (Logarithm Methodology of Additive Weights) for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: m × n matrix of objective values for n alternatives and m criteria \nweights::Array{Float64, 1}: n-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: n-vector of functions to be applied on the columns.\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\nlmaw() applies the LMAW method to rank m alternatives subject to n criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::LMAWResult: LMAWResult object that holds multiple outputs including scores, rankings, and best index.\n\nExamples\n\njulia> decMat = [\n                647.34        6.24        49.87        19.46        212.58        6.75;\n                115.64        3.24        16.26         9.69        207.59        3.00;\n                373.61        5.00        26.43        12.00        184.62        3.74;\n                 37.63        2.48         2.85         9.25        142.50        3.24;\n                858.01        4.74        62.85        45.96        267.95        4.00;\n                222.92        3.00        19.24        21.46        221.38        3.49\n                ]   \n       6×6 Matrix{Float64}:\n       647.34  6.24  49.87  19.46  212.58  6.75\n       115.64  3.24  16.26   9.69  207.59  3.0\n       373.61  5.0   26.43  12.0   184.62  3.74\n        37.63  2.48   2.85   9.25  142.5   3.24\n       858.01  4.74  62.85  45.96  267.95  4.0\n       222.92  3.0   19.24  21.46  221.38  3.49\n\njulia> weights = [0.215, 0.126, 0.152, 0.091, 0.19, 0.226];\n\njulia> fns = [maximum, maximum, minimum, minimum, minimum, maximum];\n\njulia> result = lmaw(decmat, weights, fns);\n\njulia> result.scores\n6-element Vector{Float64}:\n 4.839005264308832\n 4.679718180594332\n 4.797731427991642\n 4.732145373983716\n 4.73416833375772\n 4.702247270959649\n\njulia> result.bestIndex\n1\n\nReferences\n\nPamučar, D., Žižović, M., Biswas, S., & Božanić, D. (2021). A new logarithm methodology of additive weights (LMAW) for multi-criteria decision-making: Application in logistics. Facta Universitatis, Series: Mechanical Engineering, 19(3), 361. https://doi.org/10.22190/FUME210214031P\n\n\n\n\n\nlmaw(setting)\n\nApply LMAW (Logarithm Methodology of Additive Weights) for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\nlmaw() applies the LMAW method to rank m alternatives subject to n criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::LMAWResult: LMAWResult object that holds multiple outputs including scores, rankings, and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#LOPCOW","page":"MCDM","title":"LOPCOW","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.lopcow","category":"page"},{"location":"mcdms/#JMcDM.LOPCOW.lopcow","page":"MCDM","title":"JMcDM.LOPCOW.lopcow","text":"lopcow(decisionMat, fns; normalization)\n\nApply LOPCOW (LOgarithmic Percentage Change-driven Objective Weighting) method for a given matrix and criteria types.\n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n alternatives and m criteria \nfns::Array{<:Function, 1}: m-vector of functions to be applied on the columns.\nnormalization{<:Function}: Optional normalization function.\n\nDescription\n\nlopcow() applies the LOPCOW method to calculate objective weights using a decision matrix with   n alterntives subject to m criteria which are supposed to be either maximized or minimized.\n\nOutput\n\n::LOPCOWResult: LOPCOWResult object that holds multiple outputs including weighting and best index.\n\nExamples\n\n\njulia> decmat\n9×17 Matrix{Float64}:\n 21.8  14.1  10.7  1.6  1.8   770.0  12750.0  18.0   5100.0  1.5     9.1    1.054  4.196  29.407   7.03   15.08    9.705\n 16.4   8.5  13.9  1.2  1.3   524.0  12087.0   5.7   2941.0  2.208  15.2    1.123  3.86    5.228  14.724  32.103  19.0\n 14.5   7.0   2.3  0.2  0.2   238.0   3265.0   1.9    320.0  2.32   16.202  1.008  3.095   5.549  17.34   65.129  32.056\n 18.2  10.3  11.4  1.2  1.1   835.0  16037.0  21.3   4332.0  0.875   9.484  0.856  2.191  23.75   13.1    58.157  27.46\n 18.5   8.1  11.1  1.0  1.1   504.0   9464.0   1.4   1743.0  2.95    0.7    0.479  2.44    8.77   13.48   33.45   17.68\n 18.7  11.4  10.8  1.3  1.5  1227.0  24053.0  20.0   6521.0  0.733   1.6    0.857  2.377   4.985  11.743  26.732  24.485\n 18.5  12.6  10.8  1.4  1.8   912.0  18800.0  18.2   5300.0  1.29    8.27   0.558  0.635   5.22   13.829  31.914   7.515\n 16.4   6.7  12.6  0.9  0.9   951.0  16767.0  22.0   3917.0  2.46    3.9    0.724  0.568   4.491  14.357  28.869   7.313\n 15.2   6.3   6.9  0.5  0.5  1013.0  20170.0  10.97  4060.0  1.67    1.7    0.704  2.96    3.24   10.029  60.981  23.541\n\njulia> fns = [maximum, maximum, maximum, maximum, maximum, maximum, maximum, maximum, maximum, maximum, minimum, minimum, minimum, minimum, minimum, minimum, minimum ];\n\njulia> result = lopcow(decmat, fns);\n\njulia> result.w\n17-element Vector{Float64}:\n 0.04947396185854988\n 0.036623078374935315\n 0.08456624432002027\n 0.07055941647198624\n ⋮\n 0.07625360895444118\n 0.05507171491276535\n 0.05320727577078255\n 0.05340460620185558\n\n\nReferences\n\nEcer, F., & Pamucar, D. (2022). A novel LOPCOW‐DOBI multi‐criteria sustainability performance assessment methodology: An application in developing country banking sector. Omega, 112, 102690. https://doi.org/10.1016/j.omega.2022.102690\n\n\n\n\n\nlopcow(setting)\n\nApply LOPCOW (LOgarithmic Percentage Change-driven Objective Weighting) method for a given matrix and criteria types.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\nlopcow() applies the LOPCOW method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::LOPCOWResult: LOPCOWResult object that holds multiple outputs including weighting and best index.\n\n\n\n\n\n","category":"function"},{"location":"mcdms/#OCRA","page":"MCDM","title":"OCRA","text":"","category":"section"},{"location":"mcdms/","page":"MCDM","title":"MCDM","text":"JMcDM.ocra","category":"page"},{"location":"mcdms/#JMcDM.OCRA.ocra","page":"MCDM","title":"JMcDM.OCRA.ocra","text":"ocra(decisionMat, weights, fns)\n\nApply OCRA (Operational Competitiveness RAting) for a given matrix and weights.\n\nArguments:\n\ndecisionMat::Matrix: m × n matrix of objective values for n alternatives and m criteria \nweights::Array{Float64, 1}: n-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: n-vector of functions to be applied on the columns. \n\nDescription\n\nocra() applies the OCRA method to rank m alternatives subject to n criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::OCRAResult: OCRAResult object that holds multiple outputs including scores, rankings, and best index.\n\nExamples\n\njulia> decMat = [\n            8.0  16.0  1.5  1.2   4200.0  5.0  5.0  314.0  185.0;\n            8.0  16.0  1.0  1.3   4200.0  5.0  4.0  360.0  156.0;\n           10.1  16.0  2.0  1.3   4060.0  5.0  3.0  503.0  160.0;\n           10.1   8.0  1.0  1.5   5070.0  2.0  4.0  525.0  200.0;\n           10.0  16.0  2.0  1.2   6350.0  5.0  3.0  560.0  190.0;\n           10.1  16.0  1.0  1.2   5500.0  2.0  2.0  521.0  159.0;\n           10.1  64.0  2.0  1.7   5240.0  5.0  3.0  770.0  199.0;\n            7.0  32.0  1.0  1.8   3000.0  3.0  4.0  364.0  157.0;\n           10.1  16.0  1.0  1.3   3540.0  5.0  3.0  510.0  171.0;\n            9.7  16.0  2.0  1.83  7500.0  6.0  2.0  550.0  170.0\n       ]\n10×9 Matrix{Float64}:\n  8.0  16.0  1.5  1.2   4200.0  5.0  5.0  314.0  185.0\n  8.0  16.0  1.0  1.3   4200.0  5.0  4.0  360.0  156.0\n 10.1  16.0  2.0  1.3   4060.0  5.0  3.0  503.0  160.0\n 10.1   8.0  1.0  1.5   5070.0  2.0  4.0  525.0  200.0\n 10.0  16.0  2.0  1.2   6350.0  5.0  3.0  560.0  190.0\n 10.1  16.0  1.0  1.2   5500.0  2.0  2.0  521.0  159.0\n 10.1  64.0  2.0  1.7   5240.0  5.0  3.0  770.0  199.0\n  7.0  32.0  1.0  1.8   3000.0  3.0  4.0  364.0  157.0\n 10.1  16.0  1.0  1.3   3540.0  5.0  3.0  510.0  171.0\n  9.7  16.0  2.0  1.83  7500.0  6.0  2.0  550.0  170.0\n\njulia> weights =[0.167, 0.039, 0.247, 0.247, 0.116, 0.02, 0.056, 0.027, 0.081];\n\njulia> fns = [maximum,maximum,maximum,maximum,maximum,maximum,maximum,minimum,minimum];\n\njulia> result = ocra(decmat, weights, fns);\n\njulia> result.scores\n10-element Vector{Float64}:\n 0.14392093908214929\n 0.024106550710436096\n 0.27342011595623067\n 0.04297916544177691\n 0.31851953804157623\n 0.0024882426914910674\n 0.5921715172301161\n 0.11390289470614312\n 0.0\n 0.47874854984718046\n\njulia> result.bestIndex\n7\n\nReferences\n\nParkan, C. (1994). Operational competitiveness ratings of production units. Managerial and Decision Economics, 15(3), 201–221. doi:10.1002/mde.4090150303 \nParkan, C. (2003). Measuring the effect of a new point of sale system on the performance of drugstore operations. Computers & Operations Research, 30(5), 729–744. doi:10.1016/s0305-0548(02)00047-3 \nKundakcı, N. (2017). An Integrated Multi-Criteria Decision Making Approach for Tablet Computer Selection. European Journal of Multidisciplinary Studies, 2(5), 31-43.\n\n\n\n\n\nocra(setting)\n\nApply OCRA (Operational Competitiveness RAting) for a given matrix and weights.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \n\nDescription\n\nocra() applies the OCRA method to rank m alternatives subject to n criteria which are supposed to be  either maximized or minimized.\n\nOutput\n\n::OCRAResult: OCRAResult object that holds multiple outputs including scores, rankings, and best index.\n\n\n\n\n\n","category":"function"},{"location":"utility/#Utility-functions","page":"Utility","title":"Utility functions","text":"","category":"section"},{"location":"utility/#MCDMSetting","page":"Utility","title":"MCDMSetting","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"JMcDM.MCDMSetting","category":"page"},{"location":"utility/#JMcDM.MCDMSetting","page":"Utility","title":"JMcDM.MCDMSetting","text":"struct MCDMSetting \n    df::Matrix\n    weights::Array{Float64, 1}\n    fns::Array{Function, 1}\nend\n\nImmutable data structure for a MCDM setting.\n\nArguments\n\ndf::Matrix: The decision matrix in type of Matrix.\nweights::Array{Float64,1}: Array of weights for each criterion.\nfns::Array{<:Function, 1}: Array of functions. The elements are either minimum or maximum.\n\nDescription\n\nMany methods including Topsis, Electre, Waspas, etc., use a decision matrix, weights, and directions of optimizations in types of Matrix and Vector, respectively. The type MCDMSetting simply holds these information to pass them into methods easly. Once a MCDMSetting object is created, the problem can be passed into several methods like topsis(setting), electre(setting), waspas(setting), etc.  \n\n# Examples\n\njulia> df = DataFrame();\njulia> df[:, :x] = Float64[9, 8, 7];\njulia> df[:, :y] = Float64[7, 7, 8];\njulia> df[:, :z] = Float64[6, 9, 6];\njulia> df[:, :q] = Float64[7, 6, 6];\n\njulia> w = Float64[4, 2, 6, 8];\n\njulia> fns = [maximum, maximum, maximum, maximum];\n\njulia> setting = MCDMSetting(Matrix(df), w, fns)\n\njulia> result = topsis(setting);\njulia> # Same result can be obtained using\njulia> result2 = mcdm(setting, TopsisMethod())\n\n\n\n\n\n","category":"type"},{"location":"utility/#mcdm","page":"Utility","title":"mcdm","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"JMcDM.mcdm","category":"page"},{"location":"utility/#JMcDM.mcdm","page":"Utility","title":"JMcDM.mcdm","text":"    mcdm(df, w, fns, method)\n\nPerform selected method for a given decision matrix, weight vector, and function list.\n\nArguments:\n\ndf::Matrix: n × m matrix of decision matrix in type of Matrix. \nweights::Array{Float64, 1}: m-vector of weights for criteria.\nfs::Array{Function, 1}: m-vector of functions that are either maximize or minimize for each single criterion.\nmethod::MCDMMethod: Preferred MCDMMethod.\n\nDescription\n\nThe method is one of the subtypes of MCDMMethod type. See examples.\n\nOutput\n\n::MCDMResult: An object derived from subtypes of MCDMResult type.\n\nExamples\n\n\njulia> subtypes(MCDMMethod)\n23-element Vector{Any}:\n ArasMethod\n CocosoMethod\n CodasMethod\n CoprasMethod\n CriticMethod\n EdasMethod\n ElectreMethod\n GreyMethod\n LMAWMethod\n LOPCOWMethod\n MabacMethod\n MaircaMethod\n MarcosMethod\n MERECMethod\n MooraMethod\n MoosraMethod\n OCRAMethod\n PIVMethod\n PrometheeMethod\n PSIMethod\n ROVMethod\n SawMethod\n TopsisMethod\n VikorMethod\n WaspasMethod\n WPMMethod\n\n\njulia> # mcdm() for Topsis:\njulia> # mcdm(df, w, fns, TopsisMethod())\n\njulia> # mcdm() for Saw:\njulia> # mcdm(df, w, fns, SawMethod())\n\njulia> # mcdm() with optional parameters:\njulia> # mcdm(df, w, fns, GreyMethod(0.6))\n\n\n\n\n\nmcdm(setting, method = TopsisMethod())\n\nPerform selected method for a given decision matrix, weight vector, and function list.\n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object that holds the decision matrix, weight vector, and functions.\nmethod::MCDMMethod: Preferred MCDMMethod. The default is TopsisMethod().\n\nDescription\n\nThe method is one of the subtypes of MCDMMethod type. See examples.\n\nOutput\n\n::MCDMResult: An object derived from subtypes of MCDMResult type.\n\nExamples\n\njulia> # mcdm() for Topsis:\njulia> # mcdm(setting, TopsisMethod())\n\njulia> # mcdm() for Saw:\njulia> # mcdm(setting, SawMethod())\n\njulia> # mcdm() with optional parameters:\njulia> # mcdm(setting, GreyMethod(0.6))\n\n\n\n\n\n","category":"function"},{"location":"utility/#summary","page":"Utility","title":"summary","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"JMcDM.summary","category":"page"},{"location":"utility/#JMcDM.summary","page":"Utility","title":"JMcDM.summary","text":"    summary(decisionMat, weights, fns, methods)\n\nApply more methods for a given decision problem. The methods accept standart number of arguments.   \n\nArguments:\n\ndecisionMat::Matrix: n × m matrix of objective values for n candidate (or strategy) and m criteria \nweights::Array{Float64, 1}: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.\nfns::Array{<:Function, 1}: m-vector of function that are either minimize or maximize.\nmethods::Array{Symbol, 1}: Array of symbols. The elements can be :topsis, :electre, :cocoso, :copras, :moora, :vikor, :grey, :aras, :saw, :wpm, :waspas, :edas, :marcos, :mabac, :mairca, :copras, :critic\n\nDescription\n\nThis method outputs a summarized output using more than MCDM methods in a comparable way. \n\n# Output\n\n::Matrix: A DataFrame object, methods in columns, and alternatives in rows. Green check symbol indicates the selected alternative as the best by the corresponding method.\n\nExamples\n\njulia> df = DataFrame(\n:age        => [6.0, 4, 12],\n:size       => [140.0, 90, 140],\n:price      => [150000.0, 100000, 75000],\n:distance   => [950.0, 1500, 550],\n:population => [1500.0, 2000, 1100]);\n\n\njulia> methods = [:topsis, :electre, :vikor, :moora, :cocoso, :wpm, :waspas]\n\njulia> w  = [0.036, 0.192, 0.326, 0.326, 0.12];\n\njulia> fns = [maximum, minimum, maximum, maximum, maximum];\n\n\njulia> result = summary(Matrix(df), w, fns, methods)\n3×7 DataFrame\n Row │ topsis  electre  cocoso  moora   vikor   wpm     waspas \n     │ String  String   String  String  String  String  String \n─────┼─────────────────────────────────────────────────────────\n   1 │                           ✅      ✅\n   2 │  ✅      ✅       ✅                      ✅      ✅\n   3 │\n\n\n\n\n\n\n    summary(setting, methods)\n\nApply more methods for a given decision problem. The methods accept standart number of arguments.   \n\nArguments:\n\nsetting::MCDMSetting: MCDMSetting object. \nmethods::Array{Symbol, 1}: Array of symbols. The elements can be :topsis, :electre, :cocoso, :copras, :moora, :vikor, :grey, :aras, :saw, :wpm, :waspas, :edas, :marcos, :mabac, :mairca, :copras, :critic\n\nDescription\n\nThis method outputs a summarized output using more than MCDM methods in a comparable way.\n\n\n\n\n\n","category":"function"},{"location":"game/#Zero-sum-Game-Solver","page":"Game Solver","title":"Zero-sum Game Solver","text":"","category":"section"},{"location":"game/#game","page":"Game Solver","title":"game","text":"","category":"section"},{"location":"game/","page":"Game Solver","title":"Game Solver","text":"JMcDM.game","category":"page"},{"location":"game/#JMcDM.Game.game","page":"Game Solver","title":"JMcDM.Game.game","text":"    game(decisionMatrix; verbose = false)\n\nSolve the zero-sum game.\n\nArguments:\n\ndecisionMatrix::Array{Float,2}: n × m matrix of gain values for row player. \nverbose::Bool: Logical value indicating whether the optimization logs are shown or not. Default is false. \n\nDescription\n\ngame() solves zero-sum games using a gain matrix designed for the row player. The game matrix has n rows  and m columns for n and m strategies of row and column players, respectively. \n\nOutput\n\n::Array{GameResult, 1}: Vector of GameResult objects that holds mixed strategy probabilities for row \n\nand column players and the value of game. If a pure strategy exists, than the propabilities vector is a one-hat vector.\n\nExamples\n\njulia> # Rock & Paper & Scissors game\njulia> mat = [0 -1 1; 1 0 -1; -1 1 0]\n3×3 Array{Int64,2}:\n  0  -1   1\n  1   0  -1\n -1   1   0\n\njulia> result = game(mat);\n\njulia> result\nRow Player: \nProbabilities:\n[0.3333333333333333, 0.3333333333333333, 0.3333333333333333]\nValue of game: \n0.0\n\nColumn Player: \nProbabilities:\n[0.3333333333333333, 0.3333333333333333, 0.3333333333333333]\nValue of game: \n0.0\n\nReferences\n\nZhou, Hai-Jun. \"The rock–paper–scissors game.\" Contemporary Physics 57.2 (2016): 151-163.\n\nwarning: Dependencies\nThis method is enabled when the JuMP and Ipopt packages are installed and loaded.\n\n\n\n\n\n","category":"function"},{"location":"dataenvelop/#Data-Envelopment-Analysis","page":"Data Envelopment","title":"Data Envelopment Analysis","text":"","category":"section"},{"location":"dataenvelop/#dataenvelop","page":"Data Envelopment","title":"dataenvelop","text":"","category":"section"},{"location":"dataenvelop/","page":"Data Envelopment","title":"Data Envelopment","text":"JMcDM.dataenvelop","category":"page"},{"location":"dataenvelop/#JMcDM.DataEnvelop.dataenvelop","page":"Data Envelopment","title":"JMcDM.DataEnvelop.dataenvelop","text":"    dataenvelop(input, output; verbose = false)\n\nApply data envelop analysis for a given input matrix and an output vector.\n\nArguments:\n\ninput::Array{Float,2}: n × m matrix of input values. \noutput::Array{Float64, 1}: n-vector of output values.\nverbose::Bool: Logical value indicating whether to show optimizition logs. Default is false.\n\nDescription\n\ndataenvlope() applies the data envelop analysis to calculate efficiencies of cases.\n\nOutput\n\n::DataEnvelopResult: DataEnvelopResult object that holds many results including efficiencies and rankings.\n\nExamples\n\njulia> using JuMP, Ipopt, JMcDM\n\njulia> x1 = [96.0, 84, 90, 81, 102, 83, 108, 99, 95];\njulia> x2 = [300.0, 282, 273, 270, 309, 285, 294, 288, 306];\njulia> out = [166.0, 150, 140, 136, 171, 144, 172, 170, 165];\njulia> inp = hcat(x1, x2);\n\njulia> result = dataenvelop(inp, out);\n\njulia> result.orderedcases\n9-element Array{Symbol,1}:\n :Case8\n :Case2\n :Case7\n :Case1\n :Case9\n :Case6\n :Case5\n :Case4\n :Case3\n\njulia> result.efficiencies\n9-element Array{Float64,1}:\n 0.9879815986198964\n 0.9999999999999999\n 0.8959653733189055\n 0.9421686746987951\n 0.9659435120753173\n 0.9715662650602411\n 0.9911164465786314\n 1.0\n 0.9841048789857857\n\nReferences\n\nİşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8\n\nwarning: Dependencies\nThis method is enabled when the JuMP and Ipopt packages are installed and loaded.\n\n\n\n\n\n","category":"function"},{"location":"scdm/#Single-criterion-decision-making-tools","page":"SCDM","title":"Single-criterion decision making tools","text":"","category":"section"},{"location":"scdm/#laplace","page":"SCDM","title":"laplace","text":"","category":"section"},{"location":"scdm/","page":"SCDM","title":"SCDM","text":"JMcDM.laplace","category":"page"},{"location":"scdm/#JMcDM.SCDM.laplace","page":"SCDM","title":"JMcDM.SCDM.laplace","text":"laplace(decisionMat)\n\nApply Laplace method for a given decision matrix (for convenience, in type of Matrix).\n\nArguments:\n\ndecisionMat::Matrix: Decision matrix with n alternatives and m criteria. \n\nOutput\n\n::LaplaceResult: LaplaceResult object that holds multiple outputs including the best alternative.\n\nExamples\n\njulia> mat = [\n        3000 2750 2500 2250;\n        1500 4750 8000 7750;\n        2000 5250 8500 11750\n]\n\njulia> result = laplace(mat)\n\n\n\n\n\n","category":"function"},{"location":"scdm/#maximin","page":"SCDM","title":"maximin","text":"","category":"section"},{"location":"scdm/","page":"SCDM","title":"SCDM","text":"JMcDM.maximin","category":"page"},{"location":"scdm/#JMcDM.SCDM.maximin","page":"SCDM","title":"JMcDM.SCDM.maximin","text":"maximin(decisionMat)\n\nApply Maximin method for a given decision matrix (for convenience, in type of Matrix).\n\nArguments:\n\ndecisionMat::Matrix: Decision matrix with n alternatives and m criteria. \n\nOutput\n\n::MaximinResult: MaximinResult object that holds multiple outputs including the best alternative.\n\nExamples\n\njulia> mat = [\n        26 26 18 22;\n        22 34 30 18;\n        28 24 34 26;\n        22 30 28 20\n    ]\n\njulia> result = maximin(mat)\n\n\n\n\n\n","category":"function"},{"location":"scdm/#maximax","page":"SCDM","title":"maximax","text":"","category":"section"},{"location":"scdm/","page":"SCDM","title":"SCDM","text":"JMcDM.maximax","category":"page"},{"location":"scdm/#JMcDM.SCDM.maximax","page":"SCDM","title":"JMcDM.SCDM.maximax","text":"maximax(decisionMat)\n\nApply Maximax method for a given decision matrix (for convenience, in type of Matrix).\n\nArguments:\n\ndecisionMat::Matrix: Decision matrix with n alternatives and m criteria. \n\nOutput\n\n::MaximaxResult: MaximaxResult object that holds multiple outputs including the best alternative.\n\nExamples\n\njulia> mat = [\n        26 26 18 22;\n        22 34 30 18;\n        28 24 34 26;\n        22 30 28 20\n    ]\n\n\njulia> result = maximax(mat)\n\n\n\n\n\n","category":"function"},{"location":"scdm/#minimax","page":"SCDM","title":"minimax","text":"","category":"section"},{"location":"scdm/","page":"SCDM","title":"SCDM","text":"JMcDM.minimax","category":"page"},{"location":"scdm/#JMcDM.SCDM.minimax","page":"SCDM","title":"JMcDM.SCDM.minimax","text":"minimax(decisionMat)\n\nApply Minimax method for a given decision matrix (for convenience, in type of Matrix).\n\nArguments:\n\ndecisionMat::Matrix: Decision matrix with n alternatives and m criteria. \n\nOutput\n\n::MinimaxResult: MinimaxResult object that holds multiple outputs including the best alternative.\n\nExamples\n\njulia> mat = [\n        26 26 18 22;\n        22 34 30 18;\n        28 24 34 26;\n        22 30 28 20\n    ]\n\n\njulia> result = minimax(mat)\n\n\n\n\n\n","category":"function"},{"location":"scdm/#minimin","page":"SCDM","title":"minimin","text":"","category":"section"},{"location":"scdm/","page":"SCDM","title":"SCDM","text":"JMcDM.minimin","category":"page"},{"location":"scdm/#JMcDM.SCDM.minimin","page":"SCDM","title":"JMcDM.SCDM.minimin","text":"minimin(decisionMat)\n\nApply Minimin method for a given decision matrix (for convenience, in type of Matrix).\n\nArguments:\n\ndecisionMat::Matrix: Decision matrix with n alternatives and m criteria. \n\nOutput\n\n::MiniminResult: Minimin object that holds multiple outputs including the best alternative.\n\nExamples\n\njulia> mat = [\n        26 26 18 22;\n        22 34 30 18;\n        28 24 34 26;\n        22 30 28 20\n    ]\n\njulia> result = minimin(mat)\n\n\n\n\n\n","category":"function"},{"location":"scdm/#savage","page":"SCDM","title":"savage","text":"","category":"section"},{"location":"scdm/","page":"SCDM","title":"SCDM","text":"JMcDM.savage","category":"page"},{"location":"scdm/#JMcDM.SCDM.savage","page":"SCDM","title":"JMcDM.SCDM.savage","text":"savage(decisionMat)\n\nApply Savage method for a given decision matrix (for convenience, in type of Matrix).\n\nArguments:\n\ndecisionMat::Matrix: Decision matrix with n alternatives and m criteria. \n\nOutput\n\n::SavageResult: SavageResult object that holds multiple outputs including the best alternative.\n\nExamples\n\njulia> mat = [\n        26 26 18 22;\n        22 34 30 18;\n        28 24 34 26;\n        22 30 28 20\n    ]\n\n\njulia> result = savage(mat)\n\njulia> result.bestIndex \n4\n\n\n\n\n\n","category":"function"},{"location":"scdm/#hurwicz","page":"SCDM","title":"hurwicz","text":"","category":"section"},{"location":"scdm/","page":"SCDM","title":"SCDM","text":"JMcDM.hurwicz","category":"page"},{"location":"scdm/#JMcDM.SCDM.hurwicz","page":"SCDM","title":"JMcDM.SCDM.hurwicz","text":"hurwicz(decisionMat; alpha = 0.5)\n\nApply Hurwicz method for a given decision matrix (for convenience, in type of Matrix).\n\nArguments:\n\ndecisionMat::Matrix: Decision matrix with n alternatives and m criteria. \nalpha::Float64: The optional alpha value for the Hurwicz method. Default is 0.5.\n\nOutput\n\n::HurwiczResult: HurwiczResult object that holds multiple outputs including the best alternative.\n\nExamples\n\njulia> mat = [\n        26 26 18 22;\n        22 34 30 18;\n        28 24 34 26;\n        22 30 28 20\n    ]\n\njulia> result = hurwicz(mat)\n\njulia> result.bestIndex \n3\n\n\n\n\n\n","category":"function"},{"location":"scdm/#mle","page":"SCDM","title":"mle","text":"","category":"section"},{"location":"scdm/","page":"SCDM","title":"SCDM","text":"JMcDM.mle","category":"page"},{"location":"scdm/#JMcDM.SCDM.mle","page":"SCDM","title":"JMcDM.SCDM.mle","text":"mle(decisionMat, weights)\n\nApply MLE (Maximum Likelihood) method for a given decision matrix (for convenience, in type of Matrix) and weights.\n\nArguments:\n\ndecisionMat::Matrix: Decision matrix with n alternatives and m criteria. \nweights::Array{Float64,1}: Array of weights for each criterion that sums up to 1.0.\n\nOutput\n\n::MLEResult: MLEResult object that holds multiple outputs including the best alternative.\n\nExamples\n\njulia> mat = [\n        26 26 18 22;\n        22 34 30 18;\n        28 24 34 26;\n        22 30 28 20\n    ]\n\n\njulia> weights = [0.2, 0.5, 0.2, 0.1]\njulia> result = mle(mat, weights)\n\njulia> result.bestIndex \n2\n\n\n\n\n\n","category":"function"},{"location":"scdm/#expectedregret","page":"SCDM","title":"expectedregret","text":"","category":"section"},{"location":"scdm/","page":"SCDM","title":"SCDM","text":"JMcDM.expectedregret","category":"page"},{"location":"scdm/#JMcDM.SCDM.expectedregret","page":"SCDM","title":"JMcDM.SCDM.expectedregret","text":"expectedregret(decisionMat, weights)\n\nApply Expected Regret method for a given decision matrix (for convenience, in type of Matrix) and weights.\n\nArguments:\n\ndecisionMat::Matrix: Decision matrix with n alternatives and m criteria. \nweights::Array{Float64,1}: Array of weights for each criterion that sums up to 1.0.\n\nOutput\n\n::ExpectedRegretResult: ExpectedRegretResult object that holds multiple outputs including the best alternative.\n\nExamples\n\njulia> mat = [\n        26 26 18 22;\n        22 34 30 18;\n        28 24 34 26;\n        22 30 28 20\n    ]\n\njulia> weights = [0.2, 0.5, 0.2, 0.1]\njulia> result = expectedregret(mat, weights)\n\njulia> result.bestIndex \n2\n\n\n\n\n\n","category":"function"},{"location":"normalizations/#Normalization-Methods-for-MCDM","page":"Normalization Methods","title":"Normalization Methods for MCDM","text":"","category":"section"},{"location":"normalizations/","page":"Normalization Methods","title":"Normalization Methods","text":"In MCDM methods, e.g. topsis, aras, waspas, each single method has a predefined and default normalization method. However the normalization method can be specifically defined by setting the normalization= parameter in MCDM functions. ","category":"page"},{"location":"normalizations/","page":"Normalization Methods","title":"Normalization Methods","text":"For example the default Topsis call with Vector norm normalization is","category":"page"},{"location":"normalizations/","page":"Normalization Methods","title":"Normalization Methods","text":"topsis(data, weights, fns)","category":"page"},{"location":"normalizations/","page":"Normalization Methods","title":"Normalization Methods","text":"whereas, the same method can be called with a different normalization method like ","category":"page"},{"location":"normalizations/","page":"Normalization Methods","title":"Normalization Methods","text":"topsis(data, weights, fns, normalization = Normalizations.dividebycolumnsumnormalization","category":"page"},{"location":"normalizations/#Vector-Norm-Normalization","page":"Normalization Methods","title":"Vector Norm Normalization","text":"","category":"section"},{"location":"normalizations/","page":"Normalization Methods","title":"Normalization Methods","text":"JMcDM.Normalizations.vectornormnormalization","category":"page"},{"location":"normalizations/#JMcDM.Normalizations.vectornormnormalization","page":"Normalization Methods","title":"JMcDM.Normalizations.vectornormnormalization","text":"vectornormnormalization(data::Matrix, fns)::Matrix\n\nDefault normalization method for Topsis and Moora \n\n\n\n\n\n","category":"function"},{"location":"normalizations/#Divide-by-Column-Sums-Normalization","page":"Normalization Methods","title":"Divide by Column Sums Normalization","text":"","category":"section"},{"location":"normalizations/","page":"Normalization Methods","title":"Normalization Methods","text":"JMcDM.Normalizations.dividebycolumnsumnormalization","category":"page"},{"location":"normalizations/#JMcDM.Normalizations.dividebycolumnsumnormalization","page":"Normalization Methods","title":"JMcDM.Normalizations.dividebycolumnsumnormalization","text":"dividebycolumnsumnormalization(data::Matrix, fns)::Matrix\n\nDefault normalization method for Aras and Copras\n\n\n\n\n\n","category":"function"},{"location":"normalizations/#Max-Min-Range-Normalization","page":"Normalization Methods","title":"Max-Min Range Normalization","text":"","category":"section"},{"location":"normalizations/","page":"Normalization Methods","title":"Normalization Methods","text":"JMcDM.Normalizations.maxminrangenormalization","category":"page"},{"location":"normalizations/#JMcDM.Normalizations.maxminrangenormalization","page":"Normalization Methods","title":"JMcDM.Normalizations.maxminrangenormalization","text":"maxminrangenormalization(data::Matrix, fns)::Matrix\n\nDefault normalization method for Cocoso, Critic, Grey, Mabac, and Mairca\n\n\n\n\n\n","category":"function"},{"location":"normalizations/#Inverse-Max-Min-Range-Normalization-(max-min,-min-max)","page":"Normalization Methods","title":"Inverse Max-Min Range Normalization (max->min, min->max)","text":"","category":"section"},{"location":"normalizations/","page":"Normalization Methods","title":"Normalization Methods","text":"JMcDM.Normalizations.inversemaxminrangenormalization","category":"page"},{"location":"normalizations/#JMcDM.Normalizations.inversemaxminrangenormalization","page":"Normalization Methods","title":"JMcDM.Normalizations.inversemaxminrangenormalization","text":"inversemaxminrangenormalization(data::Matrix, fns)::Matrix\n\n\n\n\n\n","category":"function"},{"location":"normalizations/#Grouped-Max-Min-Range-Normalization","page":"Normalization Methods","title":"Grouped Max-Min Range Normalization","text":"","category":"section"},{"location":"normalizations/","page":"Normalization Methods","title":"Normalization Methods","text":"JMcDM.Normalizations.groupeddividebymaxminnormalization","category":"page"},{"location":"normalizations/#JMcDM.Normalizations.groupeddividebymaxminnormalization","page":"Normalization Methods","title":"JMcDM.Normalizations.groupeddividebymaxminnormalization","text":"groupeddividebymaxminnormalization(mat::Matrix, fns)\n\nDefault normalization method for seca.\n\n\n\n\n\n","category":"function"},{"location":"normalizations/#Divide-by-Column-Maximum-Minimum-Normalization","page":"Normalization Methods","title":"Divide by Column Maximum-Minimum Normalization","text":"","category":"section"},{"location":"normalizations/","page":"Normalization Methods","title":"Normalization Methods","text":"JMcDM.Normalizations.dividebycolumnmaxminnormalization","category":"page"},{"location":"normalizations/#JMcDM.Normalizations.dividebycolumnmaxminnormalization","page":"Normalization Methods","title":"JMcDM.Normalizations.dividebycolumnmaxminnormalization","text":"dividebycolumnmaxminnormalization(mat::Matrix, fns)\n\nDefault normalization method for Codas and Psi.\n\n\n\n\n\n","category":"function"},{"location":"normalizations/#Inverse-Divide-by-Column-Maximum-Minimum-Normalization","page":"Normalization Methods","title":"Inverse Divide by Column Maximum-Minimum Normalization","text":"","category":"section"},{"location":"normalizations/","page":"Normalization Methods","title":"Normalization Methods","text":"JMcDM.Normalizations.inversedividebycolumnmaxminnormalization","category":"page"},{"location":"normalizations/#JMcDM.Normalizations.inversedividebycolumnmaxminnormalization","page":"Normalization Methods","title":"JMcDM.Normalizations.inversedividebycolumnmaxminnormalization","text":"inversedividebycolumnmaxminnormalization(mat::Matrix, fns)\n\nDefault normalization method by Merec.\n\n\n\n\n\n","category":"function"},{"location":"normalizations/#Divide-by-All-Norm-Normalization","page":"Normalization Methods","title":"Divide by All Norm Normalization","text":"","category":"section"},{"location":"normalizations/","page":"Normalization Methods","title":"Normalization Methods","text":"JMcDM.Normalizations.dividebyallnormnormalization","category":"page"},{"location":"normalizations/#JMcDM.Normalizations.dividebyallnormnormalization","page":"Normalization Methods","title":"JMcDM.Normalizations.dividebyallnormnormalization","text":"dividebyallnormnormalization(mat::Matrix, fns)\n\nDefault normalization method for Moosra\n\n\n\n\n\n","category":"function"},{"location":"#JMcDM","page":"JMcDM","title":"JMcDM","text":"","category":"section"},{"location":"","page":"JMcDM","title":"JMcDM","text":"A package for Multiple-criteria decision-making techniques in Julia.","category":"page"},{"location":"#The-problem","page":"JMcDM","title":"The problem","text":"","category":"section"},{"location":"","page":"JMcDM","title":"JMcDM","text":"Suppose a decision process has n alternatives and m criteria  which are either to be maximized or minimized. Each single criterion has a weight 0 ≤ wᵢ ≤ 1 where sum of wᵢ is 1. fᵢ is either maximum or minimum. gⱼ(.) is the evolution function and it is choosen as gⱼ(x) = x in many methods. A multiple criteria decision problem can be represented using the decision table ","category":"page"},{"location":"","page":"JMcDM","title":"JMcDM","text":"(Image: )","category":"page"},{"location":"","page":"JMcDM","title":"JMcDM","text":"without loss of generality. When A₁, A₂, ..., Aₙ are alternatives and C₁, C₂, ..., Cₙ are different situations of a single criterion then the decision problem is said to be single criterion decision problem. If Cⱼ are strategies of two game players then gⱼ(Aᵢ) is the gain of the row player when she selects the strategy i and the column player selects the strategy Cⱼ.","category":"page"},{"location":"","page":"JMcDM","title":"JMcDM","text":"The package mainly focuses on solving these kinds of decision problems.","category":"page"},{"location":"#For-whom?","page":"JMcDM","title":"For whom?","text":"","category":"section"},{"location":"","page":"JMcDM","title":"JMcDM","text":"Multiple-criteria decision-making is an inter-discipline subject and there is a vast amount of research in the literature in this area. However, the existing software packages in this area are generally focused on a small subset of tools. JMcDM is a developer and researcher-friendly Julia package that combines the developed methods, utility functions for implementing new ones, and serves an environment for comparing results of multiple analyses.  ","category":"page"},{"location":"#Installation","page":"JMcDM","title":"Installation","text":"","category":"section"},{"location":"","page":"JMcDM","title":"JMcDM","text":"Please type ","category":"page"},{"location":"","page":"JMcDM","title":"JMcDM","text":"julia> ]\n(@v1.7) pkg> add JMcDM","category":"page"},{"location":"","page":"JMcDM","title":"JMcDM","text":"or","category":"page"},{"location":"","page":"JMcDM","title":"JMcDM","text":"julia> using Pkg\njulia> Pkg.add(\"JMcDM\")","category":"page"},{"location":"","page":"JMcDM","title":"JMcDM","text":"in Julia REPL to install package in the standard way, otherwise, you can clone the repository and type ","category":"page"},{"location":"","page":"JMcDM","title":"JMcDM","text":"julia> ]\n(@v1.7) pkg> develop .","category":"page"},{"location":"","page":"JMcDM","title":"JMcDM","text":"to start developing new methods.","category":"page"},{"location":"#Package-Dependencies","page":"JMcDM","title":"Package Dependencies","text":"","category":"section"},{"location":"","page":"JMcDM","title":"JMcDM","text":"Since the Julia package manager installs all of the dependencies automatically, a standard user doesn't need to install them manually. The package dependencies are listed below:","category":"page"},{"location":"","page":"JMcDM","title":"JMcDM","text":"DataFrames\nGLPK\nJuMP","category":"page"}]
}
