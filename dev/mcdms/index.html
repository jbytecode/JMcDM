<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MCDM · JMcDM: Julia package for multiple-criteria decision making</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>JMcDM: Julia package for multiple-criteria decision making</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>MCDM</a><ul class="internal"><li><a class="tocitem" href="#TOPSIS"><span>TOPSIS</span></a></li><li><a class="tocitem" href="#ELECTRE"><span>ELECTRE</span></a></li><li><a class="tocitem" href="#DEMATEL"><span>DEMATEL</span></a></li><li><a class="tocitem" href="#MOORA"><span>MOORA</span></a></li><li><a class="tocitem" href="#VIKOR"><span>VIKOR</span></a></li><li><a class="tocitem" href="#AHP"><span>AHP</span></a></li><li><a class="tocitem" href="#Grey-Relational-Analysis"><span>Grey Relational Analysis</span></a></li><li><a class="tocitem" href="#Non-dominated-Sorting"><span>Non-dominated Sorting</span></a></li><li><a class="tocitem" href="#SAW"><span>SAW</span></a></li><li><a class="tocitem" href="#ARAS"><span>ARAS</span></a></li><li><a class="tocitem" href="#WPM"><span>WPM</span></a></li><li><a class="tocitem" href="#WASPAS"><span>WASPAS</span></a></li><li><a class="tocitem" href="#EDAS"><span>EDAS</span></a></li><li><a class="tocitem" href="#MARCOS"><span>MARCOS</span></a></li><li><a class="tocitem" href="#MABAC"><span>MABAC</span></a></li><li><a class="tocitem" href="#MAIRCA"><span>MAIRCA</span></a></li><li><a class="tocitem" href="#COPRAS"><span>COPRAS</span></a></li><li><a class="tocitem" href="#PROMETHEE"><span>PROMETHEE</span></a></li><li><a class="tocitem" href="#CoCoSo"><span>CoCoSo</span></a></li><li><a class="tocitem" href="#Critic"><span>Critic</span></a></li><li><a class="tocitem" href="#CODAS"><span>CODAS</span></a></li><li><a class="tocitem" href="#MEREC"><span>MEREC</span></a></li><li><a class="tocitem" href="#PIV"><span>PIV</span></a></li></ul></li><li><a class="tocitem" href="../game/">Game Solver</a></li><li><a class="tocitem" href="../dataenvelop/">Data Envolepment</a></li><li><a class="tocitem" href="../scdm/">SCDM</a></li><li><a class="tocitem" href="../utility/">Utility</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MCDM</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MCDM</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jbytecode/JMcDM/blob/main/docs/src/mcdms.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Multiple-Criteria-Decision-Making-Tools"><a class="docs-heading-anchor" href="#Multiple-Criteria-Decision-Making-Tools">Multiple Criteria Decision Making Tools</a><a id="Multiple-Criteria-Decision-Making-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Criteria-Decision-Making-Tools" title="Permalink"></a></h1><h2 id="TOPSIS"><a class="docs-heading-anchor" href="#TOPSIS">TOPSIS</a><a id="TOPSIS-1"></a><a class="docs-heading-anchor-permalink" href="#TOPSIS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.Topsis.topsis" href="#JMcDM.Topsis.topsis"><code>JMcDM.Topsis.topsis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    topsis(decisionMat, weights, fns)</code></pre><p>Apply TOPSIS (Technique for Order of Preference by Similarity to Ideal Solution) method  for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of function that are either minimize or maximize.</li></ul><p><strong>Description</strong></p><p>topsis() applies the TOPSIS method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::TopsisResult</code>: TopsisResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame();
julia&gt; df[:, :x] = Float64[9, 8, 7];
julia&gt; df[:, :y] = Float64[7, 7, 8];
julia&gt; df[:, :z] = Float64[6, 9, 6];
julia&gt; df[:, :q] = Float64[7, 6, 6];

julia&gt; w = Float64[4, 2, 6, 8];

julia&gt; df
3×4 DataFrame
 Row │ x        y        z        q       
     │ Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────
   1 │     9.0      7.0      6.0      7.0
   2 │     8.0      7.0      9.0      6.0
   3 │     7.0      8.0      6.0      6.0

julia&gt; fns = makeminmax([maximum, maximum, maximum, maximum]);
julia&gt; result = topsis(df, w, fns);

julia&gt; result.bestIndex
2

julia&gt; result.scores
3-element Array{Float64,1}:
 0.38768695492211824
 0.6503238218850163
 0.08347670030339041</code></pre><p><strong>References</strong></p><p>Hwang, C.L.; Yoon, K. (1981). Multiple Attribute Decision Making: Methods and Applications. New York: Springer-Verlag</p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p><p>İşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/topsis.jl#L31-L89">source</a></section><section><div><pre><code class="nohighlight hljs">    topsis(setting)</code></pre><p>Apply TOPSIS (Technique for Order of Preference by Similarity to Ideal Solution) method  for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>topsis() applies the TOPSIS method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::TopsisResult</code>: TopsisResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/topsis.jl#L134-L148">source</a></section></article><h2 id="ELECTRE"><a class="docs-heading-anchor" href="#ELECTRE">ELECTRE</a><a id="ELECTRE-1"></a><a class="docs-heading-anchor-permalink" href="#ELECTRE" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.ELECTRE.electre" href="#JMcDM.ELECTRE.electre"><code>JMcDM.ELECTRE.electre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    electre(decisionMat, weights, fns)</code></pre><p>Apply ELECTRE (ELimination Et Choice Translating REality) method  for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of function that are either minimize or maximize.</li></ul><p><strong>Description</strong></p><p>electre() applies the ELECTRE method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized. C and D values are used to determine the best strategy. If the strategy with the highest C value  is same as the strategy with the lowest D value than the solution is unique. Otherwise, two strategies  are reported as the solution. </p><p><strong>Output</strong></p><ul><li><code>::ElectreResult</code>: ElectreResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w =  [0.110, 0.035, 0.379, 0.384, 0.002, 0.002, 0.010, 0.077];
julia&gt; Amat = [
      100 92 10 2 80 70 95 80 ;
      80  70 8  4 100 80 80 90 ;
      90 85 5 0 75 95 70 70 ; 
      70 88 20 18 60 90 95 85
    ];

julia&gt; dmat = makeDecisionMatrix(Amat);
julia&gt; fns = makeminmax([maximum for i in 1:8]);
julia&gt; result = electre(dmat, w, fns)

julia&gt; dmat
4×8 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6     Crt7     Crt8    
     │ Float64  Float64  Float64  Float64  Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────────────────────────────────────────
   1 │   100.0     92.0     10.0      2.0     80.0     70.0     95.0     80.0
   2 │    80.0     70.0      8.0      4.0    100.0     80.0     80.0     90.0
   3 │    90.0     85.0      5.0      0.0     75.0     95.0     70.0     70.0
   4 │    70.0     88.0     20.0     18.0     60.0     90.0     95.0     85.0

julia&gt; result.bestIndex
(4,)

julia&gt; result.C
4-element Array{Float64,1}:
  0.3693693693693696
  0.01501501501501501
 -2.473473473473473
  2.0890890890890894

julia&gt; result.D
4-element Array{Float64,1}:
  0.1914244325928971
 -0.19039293350192432
  2.884307608766315
 -2.885339107857288</code></pre><p><strong>References</strong></p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/electre.jl#L31-L96">source</a></section><section><div><pre><code class="nohighlight hljs">    electre(setting)</code></pre><p>Apply ELECTRE (ELimination Et Choice Translating REality) method  for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>electre() applies the ELECTRE method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized. C and D values are used to determine the best strategy. If the strategy with the highest C value  is same as the strategy with the lowest D value than the solution is unique. Otherwise, two strategies  are reported as the solution. </p><p><strong>Output</strong></p><ul><li><code>::ElectreResult</code>: ElectreResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/electre.jl#L208-L225">source</a></section></article><h2 id="DEMATEL"><a class="docs-heading-anchor" href="#DEMATEL">DEMATEL</a><a id="DEMATEL-1"></a><a class="docs-heading-anchor-permalink" href="#DEMATEL" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.DEMATEL.dematel" href="#JMcDM.DEMATEL.dematel"><code>JMcDM.DEMATEL.dematel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    dematel(comparisonMat; threshold = nothing)</code></pre><p>Apply Dematel for a given comparison matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>comparisonMat::DataFrame</code>: n × n matrix of input values in DataFrame format (for convenience) where n is the number of criteria. Values are either 0, 1, 2, 3, or 4 which indicate the level of importance of the ith criterion relative to the jth criterion.</li><li><code>threshold::Union{Nothing, Float64}</code>: Optional threshold used in calculating values of influence matrix. It is calculated when the argument is omitted. </li></ul><p><strong>Description</strong></p><p>dematel() applies the Dematel method to calculate criteria weights, possibly for use in another multi-criteria decision making tool.</p><p><strong>Output</strong></p><ul><li><code>::DematelResult</code>: DematelResult object that holds many results including weights for each single criterion.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; K = [
        0 3 0 2 0 0 0 0 3 0;
        3 0 0 0 0 0 0 0 0 2;
        4 1 0 2 1 3 1 2 3 2;
        4 1 4 0 1 2 0 1 0 0;
        3 2 3 1 0 3 0 2 0 0;
        4 1 4 4 0 0 0 1 1 3;
        3 0 0 0 0 2 0 0 0 0;
        3 0 4 3 2 3 1 0 0 0;
        4 3 2 0 0 1 0 0 0 2;
        2 1 0 0 0 0 0 0 3 0
    ];

julia&gt; dmat = makeDecisionMatrix(K);
julia&gt; result = dematel(dmat);

julia&gt; result.weights
10-element Array{Float64,1}:
 0.1686568559124561
 0.07991375718719543
 0.14006200243438863
 0.10748052790517183
 0.08789022388276985
 0.12526272598854982
 0.03067915023486491
 0.10489168834828348
 0.092654758940811
 0.06250830916550884</code></pre><p><strong>References</strong></p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/dematel.jl#L24-L75">source</a></section></article><h2 id="MOORA"><a class="docs-heading-anchor" href="#MOORA">MOORA</a><a id="MOORA-1"></a><a class="docs-heading-anchor-permalink" href="#MOORA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.MOORA.moora" href="#JMcDM.MOORA.moora"><code>JMcDM.MOORA.moora</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    moora_ratio(decisionMat, weights, fns; method = :reference)</code></pre><p>Apply MOORA (Multi-Objective Optimization By Ratio Analysis) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of function that are either maximum or minimum.</li><li><code>method::Symbol</code>: Either <code>:reference</code> or <code>:ratio</code>. By default, it is <code>:reference</code>.</li></ul><p><strong>Description</strong></p><p>moora() applies the MOORA method to rank n strategies subject to m criteria which are supposed to be  either maximized or minimized. This method has two different versions. The method parameter determines the method used. It is <code>:reference</code> by default. For the other version, it can be set to <code>:ratio</code>.  </p><p><strong>Output</strong></p><ul><li><code>::MooraResult</code>: MooraResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>References</strong></p><p>KUNDAKCI, Nilsen. &quot;Combined multi-criteria decision making approach based on MACBETH  and MULTI-MOORA methods.&quot; Alphanumeric Journal 4.1 (2016): 17-26.</p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p><p>İşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/moora.jl#L227-L257">source</a></section><section><div><pre><code class="nohighlight hljs">    moora(setting; method = :reference)</code></pre><p>Apply MOORA (Multi-Objective Optimization By Ratio Analysis) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li><li><code>method::Symbol</code>: Either <code>:reference</code> or <code>:ratio</code>. By default, it is <code>:reference</code>.</li></ul><p><strong>Description</strong></p><p>moora() applies the MOORA method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MooraResult</code>: MooraResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/moora.jl#L271-L285">source</a></section></article><h2 id="VIKOR"><a class="docs-heading-anchor" href="#VIKOR">VIKOR</a><a id="VIKOR-1"></a><a class="docs-heading-anchor-permalink" href="#VIKOR" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.VIKOR.vikor" href="#JMcDM.VIKOR.vikor"><code>JMcDM.VIKOR.vikor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    vikor(decisionMat, weights, fns; v = 0.5)</code></pre><p>Apply VIKOR (VlseKriterijumska Optimizcija I Kaompromisno Resenje in Serbian) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of function that are either maximum or minimum.</li><li><code>v::Float64</code>: Optional algorithm parameter. Default is 0.5.</li></ul><p><strong>Description</strong></p><p>vikor() applies the VIKOR method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::VikorResult</code>: VikorResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Amat = [
             100 92 10 2 80 70 95 80 ;
             80  70 8  4 100 80 80 90 ;
             90 85 5 0 75 95 70 70 ; 
             70 88 20 18 60 90 95 85
           ];

julia&gt; dmat = makeDecisionMatrix(Amat)
4×8 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6     Crt7     Crt8    
     │ Float64  Float64  Float64  Float64  Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────────────────────────────────────────
   1 │   100.0     92.0     10.0      2.0     80.0     70.0     95.0     80.0
   2 │    80.0     70.0      8.0      4.0    100.0     80.0     80.0     90.0
   3 │    90.0     85.0      5.0      0.0     75.0     95.0     70.0     70.0
   4 │    70.0     88.0     20.0     18.0     60.0     90.0     95.0     85.0

julia&gt; fns = makeminmax([maximum, maximum, maximum, maximum, maximum, maximum, maximum, maximum]);

julia&gt; result = vikor(dmat, w, fns);

julia&gt; result.scores
4-element Array{Float64,1}:
  0.7489877763052237
  0.7332093914796731
  1.0
  0.0

julia&gt; result.bestIndex
4
</code></pre><p><strong>References</strong></p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/vikor.jl#L34-L89">source</a></section><section><div><pre><code class="nohighlight hljs">    vikor(setting; v = 0.5)</code></pre><p>Apply VIKOR (VlseKriterijumska Optimizcija I Kaompromisno Resenje in Serbian) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li><li><code>v::Float64</code>: Optional algorithm parameter. Default is 0.5.</li></ul><p><strong>Description</strong></p><p>vikor() applies the VIKOR method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::VikorResult</code>: VikorResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/vikor.jl#L152-L166">source</a></section></article><h2 id="AHP"><a class="docs-heading-anchor" href="#AHP">AHP</a><a id="AHP-1"></a><a class="docs-heading-anchor-permalink" href="#AHP" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.AHP.ahp" href="#JMcDM.AHP.ahp"><code>JMcDM.AHP.ahp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AHP(comparisonMatrixList, criteriaComparisonMatrix)</code></pre><p>Apply AHP (Analytical Hierarchy Process) for a given list of comparison matrices and criteria comparison matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>comparisonMatrixList::Array{DataFrame,1}</code>: Array of comparison matrices for all of the criteria. </li><li><code>criteriaComparisonMatrix::DataFrame</code>: Criteria comparison matrix for AHP (Comparison of columns). </li></ul><p><strong>Description</strong></p><p>AHP is based on subjective comparison between criteria. The success of the method highly depends on  consistency of these comparison. The method test the consistency first. At the next step, weights are  calculated. The ordering of rows is determined by these weights.</p><p><strong>Output</strong></p><ul><li><code>::AHPResult</code>: AhpResult object that holds multiple outputs including calculated weights and scores.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; K
8×8 Array{Float64,2}:
 1.0       7.0  0.2    0.125     0.5   0.333333  0.2       1.0
 0.142857  1.0  0.125  0.111111  0.25  0.2       0.111111  0.125
 5.0       8.0  1.0    0.333333  4.0   2.0       1.0       1.0
 8.0       9.0  3.0    1.0       7.0   5.0       3.0       3.0
 2.0       4.0  0.25   0.142857  1.0   0.5       0.2       0.2
 3.0       5.0  0.5    0.2       2.0   1.0       0.333333  0.333333
 5.0       9.0  1.0    0.333333  5.0   3.0       1.0       1.0
 1.0       8.0  1.0    0.333333  5.0   3.0       1.0       1.0

julia&gt; A1
4×4 Array{Float64,2}:
 1.0       3.0  0.2       2.0
 0.333333  1.0  0.142857  0.333333
 5.0       7.0  1.0       4.0
 0.5       3.0  0.25      1.0

julia&gt; A2
4×4 Array{Float64,2}:
 1.0   0.5       4.0       5.0
 2.0   1.0       6.0       7.0
 0.25  0.166667  1.0       3.0
 0.2   0.142857  0.333333  1.0

julia&gt; A3
4×4 Array{Float64,2}:
 1.0       0.5  0.166667  3.0
 2.0       1.0  0.25      5.0
 6.0       4.0  1.0       9.0
 0.333333  0.2  0.111111  1.0

julia&gt; A4
4×4 Array{Float64,2}:
 1.0       7.0  0.25      2.0
 0.142857  1.0  0.111111  0.2
 4.0       9.0  1.0       5.0
 0.5       5.0  0.2       1.0

julia&gt; A5
4×4 Array{Float64,2}:
 1.0       6.0  2.0   3.0
 0.166667  1.0  0.25  0.333333
 0.5       4.0  1.0   2.0
 0.333333  3.0  0.5   1.0

julia&gt; A6
4×4 Array{Float64,2}:
 1.0  0.25  0.5  0.142857
 4.0  1.0   2.0  0.333333
 2.0  0.5   1.0  0.2
 7.0  3.0   5.0  1.0

julia&gt; A7
4×4 Array{Float64,2}:
 1.0       3.0   7.0  1.0
 0.333333  1.0   4.0  0.333333
 0.142857  0.25  1.0  0.142857
 1.0       3.0   7.0  1.0

julia&gt; A8
4×4 Array{Float64,2}:
 1.0    2.0       5.0       8.0
 0.5    1.0       3.0       6.0
 0.2    0.333333  1.0       3.0
 0.125  0.166667  0.333333  1.0

julia&gt; km = makeDecisionMatrix(K);
julia&gt; as = map(makeDecisionMatrix, [A1, A2, A3, A4, A5, A6, A7, A8]);
julia&gt; result = ahp(as, km);
julia&gt; result.bestIndex
3
julia&gt; result.scores
4-element Array{Float64,1}:
 0.2801050163111839
 0.14822726478768022
 0.3813036392434616
 0.19036407965767424</code></pre><p><strong>References</strong></p><p>Saaty, Thomas L. &quot;Decision making with the analytic hierarchy process.&quot; International journal of services sciences 1.1 (2008): 83-98.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/ahp.jl#L168-L270">source</a></section></article><h2 id="Grey-Relational-Analysis"><a class="docs-heading-anchor" href="#Grey-Relational-Analysis">Grey Relational Analysis</a><a id="Grey-Relational-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Grey-Relational-Analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.GREY.grey" href="#JMcDM.GREY.grey"><code>JMcDM.GREY.grey</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    grey(decisionMat, weights, fs; zeta)

Perform GRA (Grey Relational Analysis) for a given decision matrix and weights.</code></pre><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of decision matrix in type of DataFrame. </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights for criteria.</li><li><code>fs::Array{Function, 1}</code>: m-vector of functions that are either maximize or minimize for each single criterion.</li><li><code>zeta::Float64</code>: zeta parameter for the algorithm. The default is 0.5.</li></ul><p><strong>Description</strong></p><p>Applies GRA (Grey Relational Analysis).</p><p><strong>Output</strong></p><ul><li><code>::GreyResult</code>: GreyResult object that holds many values including ordering of strategies or candidates and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Decision matrix of 5 candidates and 6 criteria.
julia&gt; df = DataFrame(
               :K1 =&gt; [105000.0, 120000, 150000, 115000, 135000],
               :K2 =&gt; [105.0, 110, 120, 105, 115],
               :K3 =&gt; [10.0, 15, 12, 20, 15],
               :K4 =&gt; [4.0, 4, 3, 4, 5],
               :K5 =&gt; [300.0, 500, 550, 600, 400],
               :K6 =&gt; [10.0, 8, 12, 9, 9]
        )
5×6 DataFrame
 Row │ K1        K2       K3       K4       K5       K6      
     │ Float64   Float64  Float64  Float64  Float64  Float64 
─────┼───────────────────────────────────────────────────────
   1 │ 105000.0    105.0     10.0      4.0    300.0     10.0
   2 │ 120000.0    110.0     15.0      4.0    500.0      8.0
   3 │ 150000.0    120.0     12.0      3.0    550.0     12.0
   4 │ 115000.0    105.0     20.0      4.0    600.0      9.0
   5 │ 135000.0    115.0     15.0      5.0    400.0      9.0

julia&gt; # Direction of optimization for each single criterion
julia&gt; functionlist = [minimum, maximum, minimum, maximum, maximum, minimum];

julia&gt; # Weights
julia&gt; w = [0.05, 0.20, 0.10, 0.15, 0.10, 0.40];

julia&gt; result = grey(df, w, functionlist);

julia&gt; result.scores
5-element Array{Float64,1}:
 0.525
 0.7007142857142857
 0.5464285714285715
 0.5762820512820512
 0.650952380952381

julia&gt; result.bestIndex
2</code></pre><p><strong>References</strong></p><p>İşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/grey.jl#L36-L98">source</a></section><section><div><pre><code class="nohighlight hljs">    grey(setting; zeta)

Perform GRA (Grey Relational Analysis) for a given decision matrix and weights.</code></pre><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li><li><code>zeta::Float64</code>: zeta parameter for the algorithm. The default is 0.5.</li></ul><p><strong>Description</strong></p><p>Applies GRA (Grey Relational Analysis).</p><p><strong>Output</strong></p><ul><li><code>::GreyResult</code>: GreyResult object that holds many values including ordering of strategies or candidates and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/grey.jl#L172-L186">source</a></section></article><h2 id="Non-dominated-Sorting"><a class="docs-heading-anchor" href="#Non-dominated-Sorting">Non-dominated Sorting</a><a id="Non-dominated-Sorting-1"></a><a class="docs-heading-anchor-permalink" href="#Non-dominated-Sorting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.NDS.nds" href="#JMcDM.NDS.nds"><code>JMcDM.NDS.nds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nds(data, fns)

Sort multidimensional data using non-dominated sorting algorithm.</code></pre><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: n x k desicion matrix with n cases and k criteria.</li><li><code>fns::Array{Function, 1}</code>: Vector of functions with elements of maximum or minimum.</li></ul><p><strong>Output</strong></p><ul><li><code>::NDSResult</code>: NDSResult object that holds multiple outputs including ranks and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"> julia&gt; cases = [
               1.0 2.0 3.0;
               2.0 1.0 3.0;
               1.0 3.0 2.0;
               4.0 5.0 6.0
           ];

julia&gt; nd = makeDecisionMatrix(cases)
4×3 DataFrame
 Row │ Crt1     Crt2     Crt3    
     │ Float64  Float64  Float64 
─────┼───────────────────────────
   1 │     1.0      2.0      3.0
   2 │     2.0      1.0      3.0
   3 │     1.0      3.0      2.0
   4 │     4.0      5.0      6.0

julia&gt; result = nds(nd, makeminmax([maximum, maximum, maximum]));

julia&gt; result.ranks
4-element Array{Int64,1}:
 0
 0
 0
 3

julia&gt; result.bestIndex
4 </code></pre><p><strong>References</strong></p><p>Deb, Kalyanmoy, et al. &quot;A fast elitist non-dominated sorting genetic algorithm for multi-objective optimization: NSGA-II.&quot;  International conference on parallel problem solving from nature. Springer, Berlin, Heidelberg, 2000.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/nds.jl#L110-L158">source</a></section></article><h2 id="SAW"><a class="docs-heading-anchor" href="#SAW">SAW</a><a id="SAW-1"></a><a class="docs-heading-anchor-permalink" href="#SAW" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.SAW.saw" href="#JMcDM.SAW.saw"><code>JMcDM.SAW.saw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    saw(decisionMat, weights, fns)</code></pre><p>Apply SAW (Simple Additive Weighting) method for a given matrix and weights. This method also known as WSM (Weighted Sum Model)</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>saw() applies the SAW method to rank n strategies subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::SawResult</code>: SawResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [4.0  7  3  2  2  2  2;
                 4.0  4  6  4  4  3  7;
                 7.0  6  4  2  5  5  3;
                 3.0  2  5  3  3  2  5;
                 4.0  2  2  5  5  3  6];
julia&gt; df = makeDecisionMatrix(decmat)
5×7 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6     Crt7    
     │ Float64  Float64  Float64  Float64  Float64  Float64  Float64 
─────┼───────────────────────────────────────────────────────────────
   1 │     4.0      7.0      3.0      2.0      2.0      2.0      2.0
   2 │     4.0      4.0      6.0      4.0      4.0      3.0      7.0
   3 │     7.0      6.0      4.0      2.0      5.0      5.0      3.0
   4 │     3.0      2.0      5.0      3.0      3.0      2.0      5.0
   5 │     4.0      2.0      2.0      5.0      5.0      3.0      6.0

julia&gt; fns = convert(Array{Function,1}, [maximum for i in 1:7])
7-element Array{Function,1}:
 maximum (generic function with 16 methods)
 maximum (generic function with 16 methods)
 maximum (generic function with 16 methods)
 maximum (generic function with 16 methods)
 maximum (generic function with 16 methods)
 maximum (generic function with 16 methods)
 maximum (generic function with 16 methods)

julia&gt; weights = [0.283, 0.162, 0.162, 0.07, 0.085, 0.162, 0.076];

julia&gt; result = saw(df, weights, fns);

julia&gt; result.scores
5-element Array{Float64,1}:
 0.5532285714285714
 0.7134857142857142
 0.8374285714285714
 0.5146571428571429
 0.5793428571428572

julia&gt; result.bestIndex
3</code></pre><p><strong>References</strong></p><p>Afshari, Alireza, Majid Mojahed, and Rosnah Mohd Yusuff. &quot;Simple additive weighting approach to  personnel selection problem.&quot; International Journal of Innovation, Management and Technology  1.5 (2010): 511.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/saw.jl#L32-L98">source</a></section><section><div><pre><code class="nohighlight hljs">    saw(setting)</code></pre><p>Apply SAW (Simple Additive Weighting) method for a given matrix and weights. This method also known as WSM (Weighted Sum Model)</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>saw() applies the SAW method to rank n strategies subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::SawResult</code>: SawResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/saw.jl#L141-L156">source</a></section></article><h2 id="ARAS"><a class="docs-heading-anchor" href="#ARAS">ARAS</a><a id="ARAS-1"></a><a class="docs-heading-anchor-permalink" href="#ARAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.ARAS.aras" href="#JMcDM.ARAS.aras"><code>JMcDM.ARAS.aras</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aras(decisionMat, weights, fs)</code></pre><p>Apply ARAS (Additive Ratio ASsessment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fs::Array{Function,1}</code>: m-vector of type of criteria. The benefit criteria shown with &quot;maximum&quot;, and the cost criteria shown with &quot;minimum&quot;.</li></ul><p><strong>Description</strong></p><p>aras() applies the ARAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::ARASResult</code>: ARASResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(
    :K1 =&gt; [105000.0, 120000, 150000, 115000, 135000],
    :K2 =&gt; [105.0, 110, 120, 105, 115],
    :K3 =&gt; [10.0, 15, 12, 20, 15],
    :K4 =&gt; [4.0, 4, 3, 4, 5],
    :K5 =&gt; [300.0, 500, 550, 600, 400],
    :K6 =&gt; [10.0, 8, 12, 9, 9]
)
julia&gt; df
5×6 DataFrame
 Row │ K1        K2       K3       K4       K5       K6      
     │ Float64   Float64  Float64  Float64  Float64  Float64 
─────┼───────────────────────────────────────────────────────
   1 │ 105000.0    105.0     10.0      4.0    300.0     10.0
   2 │ 120000.0    110.0     15.0      4.0    500.0      8.0
   3 │ 150000.0    120.0     12.0      3.0    550.0     12.0
   4 │ 115000.0    105.0     20.0      4.0    600.0      9.0
   5 │ 135000.0    115.0     15.0      5.0    400.0      9.0
julia&gt; result = aras(df, w, fs);
julia&gt; result.bestIndex
2
julia&gt; result.scores
5-element Array{Float64,1}:
 0.8142406768388222
 0.8928861957614441
 0.764157900073527
 0.8422546181927358
 0.8654063509472654</code></pre><p><strong>References</strong></p><p>Zavadskas, E. K., &amp; Turskis, Z. (2010). A new additive ratio assessment (ARAS) method in multicriteria decision‐making. Technological and Economic Development of Economy, 16(2), 159-172. Yıldırım, B. F. (2015). &quot;Çok Kriterli Karar Verme Problemlerinde ARAS Yöntemi&quot;. Kafkas Üniversitesi İktisadi ve İdari Bilimler Fakültesi Dergisi, 6 (9), 285-296. http://dx.doi.org/10.18025/kauiibf.65151</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/aras.jl#L33-L82">source</a></section><section><div><pre><code class="nohighlight hljs">aras(setting)</code></pre><p>Apply ARAS (Additive Ratio ASsessment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>aras() applies the ARAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::ARASResult</code>: ARASResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/aras.jl#L135-L147">source</a></section></article><h2 id="WPM"><a class="docs-heading-anchor" href="#WPM">WPM</a><a id="WPM-1"></a><a class="docs-heading-anchor-permalink" href="#WPM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.WPM.wpm" href="#JMcDM.WPM.wpm"><code>JMcDM.WPM.wpm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    wpm(decisionMat, weights, fns)</code></pre><p>Apply WPM (Weighted Product Method) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alterntives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>wpm() applies the WPM method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::WPMResult</code>: WPMResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [3        12.5        2        120        14        3;
       5        15        3        110        38        4;
       3        13        2        120        19        3;
       4        14        2        100        31        4;
       3        15        1.5        125        40        4]
5×6 Array{Float64,2}:
 3.0  12.5  2.0  120.0  14.0  3.0
 5.0  15.0  3.0  110.0  38.0  4.0
 3.0  13.0  2.0  120.0  19.0  3.0
 4.0  14.0  2.0  100.0  31.0  4.0
 3.0  15.0  1.5  125.0  40.0  4.0

julia&gt; df = makeDecisionMatrix(decmat)
5×6 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6    
     │ Float64  Float64  Float64  Float64  Float64  Float64 
─────┼──────────────────────────────────────────────────────
   1 │     3.0     12.5      2.0    120.0     14.0      3.0
   2 │     5.0     15.0      3.0    110.0     38.0      4.0
   3 │     3.0     13.0      2.0    120.0     19.0      3.0
   4 │     4.0     14.0      2.0    100.0     31.0      4.0
   5 │     3.0     15.0      1.5    125.0     40.0      4.0

julia&gt; weights = [0.221, 0.159, 0.175, 0.127, 0.117, 0.201];

julia&gt; fns = [maximum, minimum, minimum, maximum, minimum, maximum];

julia&gt; result = wpm(df, weights, fns);

julia&gt; result.scores
5-element Array{Float64,1}:
 0.7975224331331252
 0.7532541470584717
 0.7647463553356331
 0.7873956894790834
 0.7674278741781709

julia&gt; result.bestIndex
1</code></pre><p><strong>References</strong></p><p>Zavadskas, E. K., Turskis, Z., Antucheviciene, J., &amp; Zakarevicius, A. (2012). Optimization of Weighted Aggregated Sum Product Assessment. Elektronika Ir Elektrotechnika, 122(6), 3-6. https://doi.org/10.5755/j01.eee.122.6.1810</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/wpm.jl#L32-L94">source</a></section><section><div><pre><code class="nohighlight hljs">    wpm(setting)</code></pre><p>Apply WPM (Weighted Product Method) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>wpm() applies the WPM method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::WPMResult</code>: WPMResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/wpm.jl#L139-L153">source</a></section></article><h2 id="WASPAS"><a class="docs-heading-anchor" href="#WASPAS">WASPAS</a><a id="WASPAS-1"></a><a class="docs-heading-anchor-permalink" href="#WASPAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.WASPAS.waspas" href="#JMcDM.WASPAS.waspas"><code>JMcDM.WASPAS.waspas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    waspas(decisionMat, weights, fns; lambda = 0.5)</code></pre><p>Apply WASPAS (Weighted Aggregated Sum Product ASsessment ) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alterntives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns.</li><li><code>lambda::Float64</code>: joint criterion. 0&lt;=lambda&lt;=1, default=0.5.</li></ul><p><strong>Description</strong></p><p>waspas() applies the WASPAS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::WASPASResult</code>: WASPASResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [3        12.5        2        120        14        3;
       5        15        3        110        38        4;
       3        13        2        120        19        3;
       4        14        2        100        31        4;
       3        15        1.5        125        40        4]
5×6 Array{Float64,2}:
 3.0  12.5  2.0  120.0  14.0  3.0
 5.0  15.0  3.0  110.0  38.0  4.0
 3.0  13.0  2.0  120.0  19.0  3.0
 4.0  14.0  2.0  100.0  31.0  4.0
 3.0  15.0  1.5  125.0  40.0  4.0

julia&gt; df = makeDecisionMatrix(decmat)
5×6 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6    
     │ Float64  Float64  Float64  Float64  Float64  Float64 
─────┼──────────────────────────────────────────────────────
   1 │     3.0     12.5      2.0    120.0     14.0      3.0
   2 │     5.0     15.0      3.0    110.0     38.0      4.0
   3 │     3.0     13.0      2.0    120.0     19.0      3.0
   4 │     4.0     14.0      2.0    100.0     31.0      4.0
   5 │     3.0     15.0      1.5    125.0     40.0      4.0

julia&gt; weights = [0.221, 0.159, 0.175, 0.127, 0.117, 0.201];

julia&gt; fns = [maximum, minimum, minimum, maximum, minimum, maximum];

julia&gt; lambda = 0.5;

julia&gt; result = wpm(df, weights, fns, lambda);

julia&gt; result.scores
5-element Array{Float64,1}:
 0.8050212165665626
 0.7750597051081832
 0.770180748518019
 0.7964243424353943
 0.7882389370890854

 julia&gt; result.bestIndex
 1</code></pre><p><strong>References</strong></p><p>Zavadskas, E. K., Turskis, Z., Antucheviciene, J., &amp; Zakarevicius, A. (2012). Optimization of Weighted Aggregated Sum Product Assessment. Elektronika Ir Elektrotechnika, 122(6), 3-6. https://doi.org/10.5755/j01.eee.122.6.1810 Aytaç Adalı, E. &amp; Tuş Işık, A.. (2017). Bir Tedarikçi Seçim Problemi İçin SWARA ve WASPAS Yöntemlerine Dayanan Karar Verme Yaklaşımı. International Review of Economics and Management, 5 (4) , 56-77. DOI: 10.18825/iremjournal.335408</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/waspas.jl#L34-L100">source</a></section><section><div><pre><code class="nohighlight hljs">    waspas(setting; lambda = 0.5)</code></pre><p>Apply WASPAS (Weighted Aggregated Sum Product ASsessment ) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li><li><code>lambda::Float64</code>: joint criterion. 0&lt;=lambda&lt;=1, default=0.5.</li></ul><p><strong>Description</strong></p><p>waspas() applies the WASPAS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::WASPASResult</code>: WASPASResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/waspas.jl#L155-L170">source</a></section></article><h2 id="EDAS"><a class="docs-heading-anchor" href="#EDAS">EDAS</a><a id="EDAS-1"></a><a class="docs-heading-anchor-permalink" href="#EDAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.EDAS.edas" href="#JMcDM.EDAS.edas"><code>JMcDM.EDAS.edas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    edas(decisionMat, weights, fns)</code></pre><p>Apply EDAS (Evaluation based on Distance from Average Solution) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alterntives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>edas() applies the EDAS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::EDASResult</code>: EDASResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [5000 5 5300 450;
       4500 5 5000 400;
       4500 4 4700 400;
       4000 4 4200 400;
       5000 4 7100 500;
       5000 5 5400 450;
       5500 5 6200 500;
       5000 4 5800 450]
8×4 Array{Int64,2}:
 5000  5  5300  450
 4500  5  5000  400
 4500  4  4700  400
 4000  4  4200  400
 5000  4  7100  500
 5000  5  5400  450
 5500  5  6200  500
 5000  4  5800  450

julia&gt; df = makeDecisionMatrix(decmat)
8×4 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4    
     │ Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────
   1 │  5000.0      5.0   5300.0    450.0
   2 │  4500.0      5.0   5000.0    400.0
   3 │  4500.0      4.0   4700.0    400.0
   4 │  4000.0      4.0   4200.0    400.0
   5 │  5000.0      4.0   7100.0    500.0
   6 │  5000.0      5.0   5400.0    450.0
   7 │  5500.0      5.0   6200.0    500.0
   8 │  5000.0      4.0   5800.0    450.0

julia&gt; weights = [0.25, 0.25, 0.25, 0.25];

julia&gt; fns = [maximum, maximum, minimum, minimum];

julia&gt; result = edas(df, weights, fns);

julia&gt; result.scores
8-element Array{Float64,1}:
 0.7595941163602383
 0.8860162461306114
 0.6974721951442592
 0.739657763190231
 0.05908329207449442
 0.7318326305342363
 0.6416913873322523
 0.38519414045559647

julia&gt; result.bestIndex
2</code></pre><p><strong>References</strong></p><p>Keshavarz Ghorabaee, M., Zavadskas, E. K., Olfat, L., &amp; Turskis, Z. (2015). Multi-criteria inventory classification using a new method of evaluation based on distance from average solution (EDAS). Informatica, 26(3), 435-451.</p><p>Ulutaş, A. (2017). EDAS Yöntemi Kullanılarak Bir Tekstil Atölyesi İçin Dikiş Makinesi Seçimi. İşletme Araştırmaları Dergisi, 9(2), 169-183.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/edas.jl#L29-L107">source</a></section><section><div><pre><code class="nohighlight hljs">    edas(setting)</code></pre><p>Apply EDAS (Evaluation based on Distance from Average Solution) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>edas() applies the EDAS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::EDASResult</code>: EDASResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/edas.jl#L165-L179">source</a></section></article><h2 id="MARCOS"><a class="docs-heading-anchor" href="#MARCOS">MARCOS</a><a id="MARCOS-1"></a><a class="docs-heading-anchor-permalink" href="#MARCOS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.MARCOS.marcos" href="#JMcDM.MARCOS.marcos"><code>JMcDM.MARCOS.marcos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    marcos(decisionMat, weights, fns)</code></pre><p>Apply MARCOS (Measurement Alternatives and Ranking according to COmpromise Solution) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alterntives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>marcos() applies the MARCOS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MARCOSResult</code>: MARCOSResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [8.675 8.433 8.000 7.800 8.025 8.043;
       8.825 8.600 7.420 7.463 7.825 8.229;
       8.325 7.600 8.040 7.700 7.925 7.600;
       8.525 8.667 7.180 7.375 7.750 8.071]
4×6 Array{Float64,2}:
 8.675  8.433  8.0   7.8    8.025  8.043
 8.825  8.6    7.42  7.463  7.825  8.229
 8.325  7.6    8.04  7.7    7.925  7.6
 8.525  8.667  7.18  7.375  7.75   8.071

julia&gt; df = makeDecisionMatrix(decmat)

4×6 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6    
     │ Float64  Float64  Float64  Float64  Float64  Float64 
─────┼──────────────────────────────────────────────────────
   1 │   8.675    8.433     8.0     7.8      8.025    8.043
   2 │   8.825    8.6       7.42    7.463    7.825    8.229
   3 │   8.325    7.6       8.04    7.7      7.925    7.6
   4 │   8.525    8.667     7.18    7.375    7.75     8.071

julia&gt; weights = [0.1901901901901902 , 0.15915915915915918 , 0.19819819819819823, 0.1901901901901902, 0.15115115115115116, 0.11111111111111112];

julia&gt; fns = [maximum, maximum, maximum, maximum, maximum, maximum];

julia&gt; Fns = convert(Array{Function, 1} , fns)

julia&gt; result = marcos(df, weights, Fns);

julia&gt; result.scores
4-element Array{Float64,1}:
 0.6848657890705123
 0.6727670074308345
 0.6625969531206817
 0.6611030275027843

julia&gt; result.bestIndex
1</code></pre><p><strong>References</strong></p><p>Stević, Z., Pamučar, D., Puška, A., Chatterjee, P., Sustainable supplier selection in healthcare industries using a new MCDM method: Measurement Alternatives and Ranking according to COmpromise Solution (MARCOS), Computers &amp; Industrial Engineering (2019), doi: https://doi.org/10.1016/j.cie.2019.106231</p><p>Puška, A., Stojanović, I., Maksimović, A., &amp; Osmanović, N. (2020). Evaluation software of project management used measurement of alternatives and ranking according to compromise solution (MARCOS) method. Operational Research in Engineering Sciences: Theory and Applications, 3(1), 89-102.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/marcos.jl#L30-L93">source</a></section><section><div><pre><code class="nohighlight hljs">    marcos(setting)</code></pre><p>Apply MARCOS (Measurement Alternatives and Ranking according to COmpromise Solution) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting </li></ul><p><strong>Description</strong></p><p>marcos() applies the MARCOS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MARCOSResult</code>: MARCOSResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/marcos.jl#L160-L174">source</a></section></article><h2 id="MABAC"><a class="docs-heading-anchor" href="#MABAC">MABAC</a><a id="MABAC-1"></a><a class="docs-heading-anchor-permalink" href="#MABAC" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.MABAC.mabac" href="#JMcDM.MABAC.mabac"><code>JMcDM.MABAC.mabac</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    mabac(decisionMat, weights, fns)</code></pre><p>Apply MABAC (Multi-Attributive Border Approximation area Comparison) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>mabac() applies the MABAC method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MABACResult</code>: MABACResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [2 1 4 7 6 6 7 3000;
       4 1 5 6 7 7 6 3500;
       3 2 6 6 5 6 8 4000;
       5 1 5 7 6 7 7 3000;
       4 2 5 6 7 7 6 3000;
       3 2 6 6 6 6 6 3500]
6×8 
Array{Int64,2}:
 2  1  4  7  6  6  7  3000
 4  1  5  6  7  7  6  3500
 3  2  6  6  5  6  8  4000
 5  1  5  7  6  7  7  3000
 4  2  5  6  7  7  6  3000
 3  2  6  6  6  6  6  3500

julia&gt; df = makeDecisionMatrix(decmat)
6×8 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6     Crt7     Crt8    
     │ Float64  Float64  Float64  Float64  Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────────────────────────────────────────
   1 │     2.0      1.0      4.0      7.0      6.0      6.0      7.0   3000.0
   2 │     4.0      1.0      5.0      6.0      7.0      7.0      6.0   3500.0
   3 │     3.0      2.0      6.0      6.0      5.0      6.0      8.0   4000.0
   4 │     5.0      1.0      5.0      7.0      6.0      7.0      7.0   3000.0
   5 │     4.0      2.0      5.0      6.0      7.0      7.0      6.0   3000.0
   6 │     3.0      2.0      6.0      6.0      6.0      6.0      6.0   3500.0

julia&gt; weights = [0.293, 0.427, 0.067, 0.027, 0.053, 0.027, 0.053, 0.053];

julia&gt; fns = [maximum, maximum, maximum, maximum, maximum, maximum, maximum, minimum];

julia&gt; result = mabac(df, weights, fns);

julia&gt; result.scores
6-element Array{Float64,1}:
 -0.3113160790692055
 -0.10898274573587217
  0.2003505875974611
  0.0421839209307945
  0.3445172542641278
  0.2003505875974611

julia&gt; result.bestIndex
5</code></pre><p><strong>References</strong></p><p>Pamučar, D., &amp; Ćirović, G. (2015). The selection of transport and handling resources in logistics centers using Multi-Attributive Border Approximation area Comparison (MABAC). Expert Systems with Applications, 42(6), 3016–3028. doi:10.1016/j.eswa.2014.11.057</p><p>Ulutaş, A. (2019). Entropi ve MABAC yöntemleri ile personel seçimi. OPUS–International Journal of Society Researches, 13(19), 1552-1573. DOI: 10.26466/opus.580456</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/mabac.jl#L34-L104">source</a></section><section><div><pre><code class="nohighlight hljs">    mabac(setting)</code></pre><p>Apply MABAC (Multi-Attributive Border Approximation area Comparison) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>mabac() applies the MABAC method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MABACResult</code>: MABACResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/mabac.jl#L164-L178">source</a></section></article><h2 id="MAIRCA"><a class="docs-heading-anchor" href="#MAIRCA">MAIRCA</a><a id="MAIRCA-1"></a><a class="docs-heading-anchor-permalink" href="#MAIRCA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.MAIRCA.mairca" href="#JMcDM.MAIRCA.mairca"><code>JMcDM.MAIRCA.mairca</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    mairca(decisionMat, weights, fns)</code></pre><p>Apply MAIRCA (Multi Attributive Ideal-Real Comparative Analysis) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>mairca() applies the MAIRCA method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MAIRCAResult</code>: MAIRCAResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [6.952 8.000 6.649 7.268 8.000 7.652 6.316;
       7.319 7.319 6.604 7.319 8.000 7.652 5.313;
       7.000 7.319 7.652 6.952 7.652 6.952 4.642;
       7.319 6.952 6.649 7.319 7.652 6.649 5.000]
4×7 Array{Float64,2}:
 6.952  8.0    6.649  7.268  8.0    7.652  6.316
 7.319  7.319  6.604  7.319  8.0    7.652  5.313
 7.0    7.319  7.652  6.952  7.652  6.952  4.642
 7.319  6.952  6.649  7.319  7.652  6.649  5.0

 julia&gt; df = makeDecisionMatrix(decmat)
 4×7 DataFrame
  Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6     Crt7    
      │ Float64  Float64  Float64  Float64  Float64  Float64  Float64 
 ─────┼───────────────────────────────────────────────────────────────
    1 │   6.952    8.0      6.649    7.268    8.0      7.652    6.316
    2 │   7.319    7.319    6.604    7.319    8.0      7.652    5.313
    3 │   7.0      7.319    7.652    6.952    7.652    6.952    4.642
    4 │   7.319    6.952    6.649    7.319    7.652    6.649    5.0

julia&gt; weights = [0.172, 0.165, 0.159, 0.129, 0.112, 0.122, 0.140];

julia&gt; fns = [maximum, maximum, maximum, maximum, maximum, maximum, minimum];

julia&gt; result = mairca(df, weights, fns);

julia&gt; result.scores
4-element Array{Float64,1}:
 0.12064543054088471
 0.08066456363291889
 0.14586265389012484
 0.14542366685864686

julia&gt; result.bestIndex
2</code></pre><p><strong>References</strong></p><p>Pamučar, D., Lukovac, V., Božanić, D., &amp; Komazec, N. (2018). Multi-criteria FUCOM-MAIRCA model for the evaluation of level crossings: case study in the Republic of Serbia. Operational Research in Engineering Sciences: Theory and Applications, 1(1), 108-129.</p><p>Ulutaş A.(2019),Swara Ve Mairca Yöntemleri İle Catering Firması Seçimi,BMIJ, (2019), 7(4): 1467-1479 http://dx.doi.org/10.15295/bmij.v7i4.1166</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/mairca.jl#L30-L91">source</a></section><section><div><pre><code class="nohighlight hljs">    mairca(setting)</code></pre><p>Apply MAIRCA (Multi Attributive Ideal-Real Comparative Analysis) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>mairca() applies the MAIRCA method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MAIRCAResult</code>: MAIRCAResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/mairca.jl#L146-L160">source</a></section></article><h2 id="COPRAS"><a class="docs-heading-anchor" href="#COPRAS">COPRAS</a><a id="COPRAS-1"></a><a class="docs-heading-anchor-permalink" href="#COPRAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.COPRAS.copras" href="#JMcDM.COPRAS.copras"><code>JMcDM.COPRAS.copras</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copras(decisionMat, weights, fs)</code></pre><p>Apply COPRAS (COmplex PRoportional ASsesment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fs::Array{Function,1}</code>: m-vector of type of criteria. The benefit criteria shown with &quot;maximum&quot;, and the cost criteria shown with &quot;minimum&quot;.</li></ul><p><strong>Description</strong></p><p>copras() applies the COPRAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::COPRASResult</code>: COPRASResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [2.50 240 57 45 1.10 0.333333;
       2.50 285 60 75 4.00 0.428571;
       4.50 320 100 65 7.50 1.111111;
       4.50 365 100 90 7.50 1.111111;
       5.00 400 100 90 11.00 1.111111;
       2.50 225 60 45 1.10 0.333333;
       2.50 270 57 60 4.00 0.428571;
       4.50 330 100 70 7.50 1.111111;
       4.50 365 100 80 7.50 1.111111;
       5.00 380 110 65 8.00 1.111111;
       2.50 285 65 80 4.00 0.400000;
       4.00 280 75 65 4.00 0.400000;
       4.50 365 102 95 7.50 1.111111;
       4.50 400 102 95 7.50 1.111111;
       6.00 450 110 95 11.00 1.176471;
       6.00 510 110 105 11.00 1.176471;
       6.00 330 140 110 18.50 1.395349;
       2.50 240 65 80 4.00 0.400000;
       4.00 280 75 75 4.00 0.400000;
       4.50 355 102 95 7.50 1.111111;
       4.50 385 102 90 7.50 1.111111;
       5.00 385 114 95 7.50 1.000000;
       6.00 400 110 90 11.00 1.000000;
       6.00 480 110 95 15.00 1.000000;
       6.00 440 140 100 18.50 1.200000;
       6.00 500 140 100 18.50 1.200000;
       5.00 450 125 100 15.00 1.714286;
       6.00 500 150 125 18.50 1.714286;
       6.00 515 180 140 22.00 2.307692;
       7.00 550 200 150 30.00 2.307692;
       6.00 500 180 140 15.00 2.307692;
       6.00 500 180 140 18.50 2.307692;
       6.00 500 180 140 22.00 2.307692;
       7.00 500 180 140 30.00 2.307692;
       7.00 500 200 140 37.00 2.307692;
       7.00 500 200 140 45.00 2.307692;
       7.00 500 200 140 55.00 2.307692;
       7.00 500 200 140 75.00 2.307692]
38×6 Array{Float64,2}:
 2.5  240.0   57.0   45.0   1.1  0.333333
 2.5  285.0   60.0   75.0   4.0  0.428571
 4.5  320.0  100.0   65.0   7.5  1.11111
 4.5  365.0  100.0   90.0   7.5  1.11111
 5.0  400.0  100.0   90.0  11.0  1.11111
 2.5  225.0   60.0   45.0   1.1  0.333333
 2.5  270.0   57.0   60.0   4.0  0.428571
 4.5  330.0  100.0   70.0   7.5  1.11111
 4.5  365.0  100.0   80.0   7.5  1.11111
 5.0  380.0  110.0   65.0   8.0  1.11111
 2.5  285.0   65.0   80.0   4.0  0.4
 ⋮                               ⋮
 6.0  500.0  150.0  125.0  18.5  1.71429
 6.0  515.0  180.0  140.0  22.0  2.30769
 7.0  550.0  200.0  150.0  30.0  2.30769
 6.0  500.0  180.0  140.0  15.0  2.30769
 6.0  500.0  180.0  140.0  18.5  2.30769
 6.0  500.0  180.0  140.0  22.0  2.30769
 7.0  500.0  180.0  140.0  30.0  2.30769
 7.0  500.0  200.0  140.0  37.0  2.30769
 7.0  500.0  200.0  140.0  45.0  2.30769
 7.0  500.0  200.0  140.0  55.0  2.30769
 7.0  500.0  200.0  140.0  75.0  2.30769

julia&gt; df = makeDecisionMatrix(decmat)
38×6 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6     
     │ Float64  Float64  Float64  Float64  Float64  Float64  
─────┼───────────────────────────────────────────────────────
   1 │     2.5    240.0     57.0     45.0      1.1  0.333333
   2 │     2.5    285.0     60.0     75.0      4.0  0.428571
   3 │     4.5    320.0    100.0     65.0      7.5  1.11111
   4 │     4.5    365.0    100.0     90.0      7.5  1.11111
   5 │     5.0    400.0    100.0     90.0     11.0  1.11111
   6 │     2.5    225.0     60.0     45.0      1.1  0.333333
   7 │     2.5    270.0     57.0     60.0      4.0  0.428571
   8 │     4.5    330.0    100.0     70.0      7.5  1.11111
   9 │     4.5    365.0    100.0     80.0      7.5  1.11111
  ⋮  │    ⋮        ⋮        ⋮        ⋮        ⋮        ⋮
  30 │     7.0    550.0    200.0    150.0     30.0  2.30769
  31 │     6.0    500.0    180.0    140.0     15.0  2.30769
  32 │     6.0    500.0    180.0    140.0     18.5  2.30769
  33 │     6.0    500.0    180.0    140.0     22.0  2.30769
  34 │     7.0    500.0    180.0    140.0     30.0  2.30769
  35 │     7.0    500.0    200.0    140.0     37.0  2.30769
  36 │     7.0    500.0    200.0    140.0     45.0  2.30769
  37 │     7.0    500.0    200.0    140.0     55.0  2.30769
  38 │     7.0    500.0    200.0    140.0     75.0  2.30769
                                              20 rows omitted

julia&gt; weights = [0.1667, 0.1667, 0.1667, 0.1667, 0.1667, 0.1667];

julia&gt; fns = [maximum, maximum, maximum, maximum, maximum, minimum];

julia&gt; result = copras(df, w, fs);

julia&gt; result.bestIndex
38

julia&gt; result.scores
38-element Array{Float64,1}:
 0.021727395411605937
 0.019814414550092637
 0.01789214190869233
 0.01624057709923278
 0.01507318798582843
 0.021837811311495522
 0.020735423365838293
 0.01754833367014725
 0.016658288043259514
 0.016258710042371068
 0.019388734250223458
 ⋮
 0.01064826476628102
 0.01000964101170639
 0.007056714858865703
 0.010627520153194962
 0.010419795157349462
 0.010212070161503961
 0.00876261130160425
 0.007733739643860005
 0.007258939653356005
 0.006665439665226005
 0.005478439688966004</code></pre><p><strong>References</strong></p><p>Kaklauskas, A., Zavadskas, E. K., Raslanas, S., Ginevicius, R., Komka, A., &amp; Malinauskas, P. (2006). Selection of low-e windows in retrofit of public buildings by applying multiple criteria method COPRAS: A Lithuanian case. Energy and buildings, 38(5), 454-462. Özdağoğlu, A. (2013). İmalat işletmeleri için eksantrik pres alternatiflerinin COPRAS yöntemi ile karşılaştırılması. Gümüşhane Üniversitesi Sosyal Bilimler Enstitüsü Elektronik Dergisi, 4(8), 1-22. Yıldırım, B. F., Timor, M. (2019). &quot;Bulanık ve Gri COPRAS Yöntemleri Kullanılarak Tedarikçi Seçim Modeli Geliştirilmesi&quot;. Optimum Ekonomi ve Yönetim Bilimleri Dergisi, 6 (2), 283-310.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/copras.jl#L30-L175">source</a></section><section><div><pre><code class="nohighlight hljs">copras(setting)</code></pre><p>Apply COPRAS (COmplex PRoportional ASsesment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>copras() applies the COPRAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::COPRASResult</code>: COPRASResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/copras.jl#L229-L241">source</a></section></article><h2 id="PROMETHEE"><a class="docs-heading-anchor" href="#PROMETHEE">PROMETHEE</a><a id="PROMETHEE-1"></a><a class="docs-heading-anchor-permalink" href="#PROMETHEE" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.PROMETHEE.promethee" href="#JMcDM.PROMETHEE.promethee"><code>JMcDM.PROMETHEE.promethee</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    promethee(decisionMatrix, weights, fns, prefs, qs, ps)</code></pre><p>Apply PROMETHEE (Preference Ranking Organization METHod for Enrichment of Evaluations) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMatrix::DataFrame</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions that are either maximum or minimum.</li><li><code>prefs::Array{Function, 1}</code>: m-vector of preference functions that are prometLinear, prometVShape, prometUShape, prometQuasi, or prometLevel.</li><li><code>qs::Array{Float64, 1}</code>: m-vector of q parameters that is used in corresponding preference function.</li><li><code>ps::Array{Float64, 1}</code>: m-vector of p parameters that is used in corresponding preference function</li></ul><p><strong>Description</strong></p><p>promethee() applies the PROMETHEE method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::PrometheeResult</code>: PrometheeResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [42.0 35 43 51; 
                     89 72 92 85;
                     14 85 17 40;
                     57 60 45 80;
                     48 32 43 40;
                     71 45 60 85;
                     69 40 72 55;
                     64 35 70 60];

julia&gt; df = makeDecisionMatrix(decmat)
8×4 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4    
     │ Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────
   1 │    42.0     35.0     43.0     51.0
   2 │    89.0     72.0     92.0     85.0
   3 │    14.0     85.0     17.0     40.0
   4 │    57.0     60.0     45.0     80.0
   5 │    48.0     32.0     43.0     40.0
   6 │    71.0     45.0     60.0     85.0
   7 │    69.0     40.0     72.0     55.0
   8 │    64.0     35.0     70.0     60.0

julia&gt; qs = [49, nothing, 45, 30];

julia&gt; ps = [100, 98, 95, 80];

julia&gt; weights = [0.25, 0.35, 0.22, 0.18];

julia&gt; fns = makeminmax([maximum, maximum, maximum, maximum]);

julia&gt; prefs = convert(Array{Function,1}, [prometLinear, prometVShape, prometLinear, prometLinear]);

julia&gt; result = promethee(df, weights, fns, prefs, qs, ps);

julia&gt; result.scores
8-element Array{Float64,1}:
  0.0698938775510204
 -0.148590956382553
 -0.061361984793917565
 -0.04780408163265306
  0.09859591836734694
 -0.0006389755902360891
  0.03236974789915966
  0.057536454581832736

julia&gt; result.bestIndex
5</code></pre><p><strong>References</strong></p><p>İşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/promethee.jl#L104-L179">source</a></section><section><div><pre><code class="nohighlight hljs">    promethee(setting, prefs, qs, ps)</code></pre><p>Apply PROMETHEE (Preference Ranking Organization METHod for Enrichment of Evaluations) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li><li><code>prefs::Array{Function, 1}</code>: m-vector of preference functions that are prometLinear, prometVShape, prometUShape, prometQuasi, or prometLevel.</li><li><code>qs::Array{Float64, 1}</code>: m-vector of q parameters that is used in corresponding preference function.</li><li><code>ps::Array{Float64, 1}</code>: m-vector of p parameters that is used in corresponding preference function</li></ul><p><strong>Description</strong></p><p>promethee() applies the PROMETHEE method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::PrometheeResult</code>: PrometheeResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/promethee.jl#L226-L243">source</a></section></article><h2 id="CoCoSo"><a class="docs-heading-anchor" href="#CoCoSo">CoCoSo</a><a id="CoCoSo-1"></a><a class="docs-heading-anchor-permalink" href="#CoCoSo" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.COCOSO.cocoso" href="#JMcDM.COCOSO.cocoso"><code>JMcDM.COCOSO.cocoso</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    cocoso(decisionMat, weights, fns; lambda)</code></pre><p>Apply CoCoSo (Combined Compromise Solution) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns.</li><li><code>lambda::Float64</code>: joint criterion. 0&lt;=lambda&lt;=1, default=0.5.</li></ul><p><strong>Description</strong></p><p>cocoso() applies the CoCoSo method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::CoCoSoResult</code>: CoCoSoResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [3        12.5        2        120        14        3;
       5        15        3        110        38        4;
       3        13        2        120        19        3;
       4        14        2        100        31        4;
       3        15        1.5        125        40        4]
5×6 Array{Float64,2}:
 3.0  12.5  2.0  120.0  14.0  3.0
 5.0  15.0  3.0  110.0  38.0  4.0
 3.0  13.0  2.0  120.0  19.0  3.0
 4.0  14.0  2.0  100.0  31.0  4.0
 3.0  15.0  1.5  125.0  40.0  4.0

julia&gt; df = makeDecisionMatrix(decmat)
5×6 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6    
     │ Float64  Float64  Float64  Float64  Float64  Float64 
─────┼──────────────────────────────────────────────────────
   1 │     3.0     12.5      2.0    120.0     14.0      3.0
   2 │     5.0     15.0      3.0    110.0     38.0      4.0
   3 │     3.0     13.0      2.0    120.0     19.0      3.0
   4 │     4.0     14.0      2.0    100.0     31.0      4.0
   5 │     3.0     15.0      1.5    125.0     40.0      4.0

julia&gt; weights = [0.221, 0.159, 0.175, 0.127, 0.117, 0.201];

julia&gt; fns = [maximum, minimum, minimum, maximum, minimum, maximum];

julia&gt; lambda = 0.5;

julia&gt; result = cocoso(df, weights, fns, lambda);

julia&gt; result.scores
7-element Array{Float64,1}:
 2.0413128390265998
 2.787989783418825
 2.8823497955972495
 2.4160457689259287
 1.2986918936013303
 1.4431429073391682
 2.519094173200623

julia&gt; result.bestIndex
3</code></pre><p><strong>References</strong></p><p>Yazdani, M., Zarate, P., Kazimieras Zavadskas, E. and Turskis, Z. (2019), &quot;A combined compromise solution (CoCoSo) method for multi-criteria decision-making problems&quot;, Management Decision, Vol. 57 No. 9, pp. 2501-2519. https://doi.org/10.1108/MD-05-2017-0458</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/cocoso.jl#L33-L101">source</a></section><section><div><pre><code class="nohighlight hljs">    cocoso(setting; lambda)</code></pre><p>Apply CoCoSo (Combined Compromise Solution) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object </li><li><code>lambda::Float64</code>: joint criterion. 0&lt;=lambda&lt;=1, default=0.5.</li></ul><p><strong>Description</strong></p><p>cocoso() applies the CoCoSo method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::CoCoSoResult</code>: CoCoSoResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/cocoso.jl#L159-L174">source</a></section></article><h2 id="Critic"><a class="docs-heading-anchor" href="#Critic">Critic</a><a id="Critic-1"></a><a class="docs-heading-anchor-permalink" href="#Critic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.CRITIC.critic" href="#JMcDM.CRITIC.critic"><code>JMcDM.CRITIC.critic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    critic(decisionMat, fns)</code></pre><p>Apply CRITIC (Combined Compromise Solution) method for a given matrix and criteria types.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns.</li></ul><p><strong>Description</strong></p><p>critic() applies the CRITIC method to calculate weights using a decision matrix with   n alterntives subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::CRITICResult</code>: CRITICResult object that holds multiple outputs including weighting and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">
julia&gt; decmat
3×4 Array{Float64,2}:
 12.9918  0.7264  -1.1009  1.59814
  4.1201  5.8824   3.4483  1.02156
  4.1039  0.0     -0.5076  0.984469

julia&gt; df = makeDecisionMatrix(decmat)

3×4 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     
     │ Float64  Float64  Float64  Float64  
─────┼─────────────────────────────────────
   1 │ 12.9918   0.7264  -1.1009  1.59814
   2 │  4.1201   5.8824   3.4483  1.02156
   3 │  4.1039   0.0     -0.5076  0.984469

julia&gt; fns = [maximum, maximum, minimum, maximum];

julia&gt; result = critic(df, fns);

julia&gt; result.w
4-element Array{Float64,1}:
 0.16883905506169491
 0.41844653698732126
 0.24912338769165807
 0.16359102025932576
</code></pre><p><strong>References</strong></p><p>Diakoulaki, D., Mavrotas, G., &amp; Papayannakis, L. (1995). Determining objective weights in multiple criteria problems: The critic method. Computers &amp; Operations Research, 22(7), 763–770. doi:10.1016/0305-0548(94)00059-h  Akçakanat, Ö., Aksoy, E., Teker, T. (2018). CRITIC ve MDL Temelli EDAS Yöntemi ile TR-61 Bölgesi Bankalarının Performans Değerlendirmesi. Süleyman Demirel Üniversitesi Sosyal Bilimler Enstitüsü Dergisi, 1 (32), 1-24.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/critic.jl#L24-L76">source</a></section><section><div><pre><code class="nohighlight hljs">    critic(setting)</code></pre><p>Apply CRITIC (Combined Compromise Solution) method for a given matrix and criteria types.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>critic() applies the CRITIC method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::CRITICResult</code>: CRITICResult object that holds multiple outputs including weighting and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/critic.jl#L123-L137">source</a></section></article><h2 id="CODAS"><a class="docs-heading-anchor" href="#CODAS">CODAS</a><a id="CODAS-1"></a><a class="docs-heading-anchor-permalink" href="#CODAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.CODAS.codas" href="#JMcDM.CODAS.codas"><code>JMcDM.CODAS.codas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">codas(decisionMat, weights, fs)</code></pre><p>Apply CODAS (COmbinative Distance-based ASsessment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fs::Array{Function,1}</code>: m-vector of type of criteria. The benefit criteria shown with &quot;maximum&quot;, and the cost criteria shown with &quot;minimum&quot;.</li><li><code>tau::Float64</code>: tau parameter for the algorithm. The default is 0.02.</li></ul><p><strong>Description</strong></p><p>codas() applies the CODAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::CODASResult</code>: CODASResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat
7×5 Array{Float64,2}:
 60.0   0.4   2540.0   500.0   990.0
  6.35  0.15  1016.0  3000.0  1041.0
  6.8   0.1   1727.2  1500.0  1676.0
 10.0   0.2   1000.0  2000.0   965.0
  2.5   0.1    560.0   500.0   915.0
  4.5   0.08  1016.0   350.0   508.0
  3.0   0.1   1778.0  1000.0   920.0

julia&gt; df = DataFrame(decmat)
7×5 DataFrame
 Row │ x1       x2       x3       x4       x5      
     │ Float64  Float64  Float64  Float64  Float64 
─────┼─────────────────────────────────────────────
   1 │   60.0      0.4    2540.0    500.0    990.0
   2 │    6.35     0.15   1016.0   3000.0   1041.0
   3 │    6.8      0.1    1727.2   1500.0   1676.0
   4 │   10.0      0.2    1000.0   2000.0    965.0
   5 │    2.5      0.1     560.0    500.0    915.0
   6 │    4.5      0.08   1016.0    350.0    508.0
   7 │    3.0      0.1    1778.0   1000.0    920.0
julia&gt; result = codas(df, w, fs);
julia&gt; result.bestIndex
2
julia&gt; result.scores
7-element Array{Float64,1}:
  0.5121764914884954
  1.463300034504913
  1.0715325899642418
 -0.21246799780012637
 -1.8515205523193041
 -1.1716767695713806
  0.18865620373316055
</code></pre><p><strong>References</strong></p><p>Keshavarz Ghorabaee, M., Zavadskas, E. K., Turskis, Z., &amp; Antucheviciene, J. (2016). A new combinative distance-based assessment (CODAS) method for multi-criteria decision-making. Economic Computation &amp; Economic Cybernetics Studies &amp; Research, 50(3), 25-44.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/codas.jl#L35-L91">source</a></section><section><div><pre><code class="nohighlight hljs">codas(setting; tau = 0.02)</code></pre><p>Apply CODAS (COmbinative Distance-based ASsessment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li><li><code>tau::Float64</code>: tau parameter for the algorithm. The default is 0.02.</li></ul><p><strong>Description</strong></p><p>codas() applies the CODAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::CODASResult</code>: CODASResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/codas.jl#L180-L194">source</a></section></article><h2 id="MEREC"><a class="docs-heading-anchor" href="#MEREC">MEREC</a><a id="MEREC-1"></a><a class="docs-heading-anchor-permalink" href="#MEREC" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.MEREC.merec" href="#JMcDM.MEREC.merec"><code>JMcDM.MEREC.merec</code></a> — <span class="docstring-category">Function</span></header><section><div><p>merec(decisionMat, fns)</p><p>Apply MEREC (MEthod based on the Removal Effects of Criteria) for a given matrix and criteria types.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns.</li></ul><p><strong>Description</strong></p><p>merec() applies the MEREC method to calculate weights using a decision matrix with   n alternatives subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MERECResult</code>: MERECResult object that holds multiple outputs including weights.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">
julia&gt; decisionMat = DataFrame(
                   :K1 =&gt; [450, 10, 100, 220, 5],
                   :K2 =&gt; [8000, 9100, 8200, 9300, 8400],
                   :K3 =&gt; [54, 2, 31, 1, 23],
                   :K4 =&gt; [145, 160, 153, 162, 158]
               )
5×4 DataFrame
 Row │ K1     K2     K3     K4    
     │ Int64  Int64  Int64  Int64 
─────┼────────────────────────────
   1 │   450   8000     54    145
   2 │    10   9100      2    160
   3 │   100   8200     31    153
   4 │   220   9300      1    162
   5 │     5   8400     23    158

julia&gt; fs = [maximum, maximum, minimum, minimum];

julia&gt; result = merec(decisionMat, fs);

julia&gt; result.w
4-element Vector{Float64}:
 0.5752216672093823
 0.01409659116846726
 0.40156136388773117
 0.009120377734419302
</code></pre><p><strong>References</strong></p><p>Keshavarz-Ghorabaee, M., Amiri, M., Zavadskas, E. K., Turskis, Z., &amp; Antucheviciene, J. (2021). Determination of Objective Weights Using a New Method Based on the Removal Effects of Criteria (MEREC). Symmetry, 13(4), 525. https://doi.org/10.3390/sym13040525</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/merec.jl#L24-L75">source</a></section><section><div><pre><code class="nohighlight hljs">    merec(setting)</code></pre><p>Apply MEREC (MEthod based on the Removal Effects of Criteria) for a given matrix and criteria types.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>merec() applies the MEREC method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MERECResult</code>: MERECResult object that holds multiple outputs including weighting and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/merec.jl#L129-L143">source</a></section></article><h2 id="PIV"><a class="docs-heading-anchor" href="#PIV">PIV</a><a id="PIV-1"></a><a class="docs-heading-anchor-permalink" href="#PIV" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.PIV.piv" href="#JMcDM.PIV.piv"><code>JMcDM.PIV.piv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">piv(decisionMat, weights, fs)</code></pre><p>Apply PIV (Proximity Indexed Value) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fs::Array{Function,1}</code>: m-vector of type of criteria. The benefit criteria shown with &quot;maximum&quot;, and the cost criteria shown with &quot;minimum&quot;.</li></ul><p><strong>Description</strong></p><p>piv() applies the PIV method to rank n alternatives subject to m criteria and criteria type vector. Alternatives  with lesser scores values (u_i values in the original article) are better as they represent the deviation  from the ideal values.</p><p><strong>Output</strong></p><ul><li><code>::PIVResult</code>: PIVResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>References</strong></p><p>Sameera Mufazzal, S.M. Muzakkir, A new multi-criterion decision making (MCDM) method based on proximity indexed value for minimizing rank reversals, Computers &amp; Industrial Engineering, Volume 119, 2018, Pages 427-438, ISSN 0360-8352, https://doi.org/10.1016/j.cie.2018.03.045.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/2265a44a3e62e8c413c729554c53f2b810f11281/src/piv.jl#L32-L54">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="../game/">Game Solver »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Sunday 14 August 2022 08:10">Sunday 14 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
