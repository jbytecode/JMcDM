<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MCDM · JMcDM: Julia package for multiple-criteria decision making</title><meta name="title" content="MCDM · JMcDM: Julia package for multiple-criteria decision making"/><meta property="og:title" content="MCDM · JMcDM: Julia package for multiple-criteria decision making"/><meta property="twitter:title" content="MCDM · JMcDM: Julia package for multiple-criteria decision making"/><meta name="description" content="Documentation for JMcDM: Julia package for multiple-criteria decision making."/><meta property="og:description" content="Documentation for JMcDM: Julia package for multiple-criteria decision making."/><meta property="twitter:description" content="Documentation for JMcDM: Julia package for multiple-criteria decision making."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>JMcDM: Julia package for multiple-criteria decision making</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>MCDM</a><ul class="internal"><li><a class="tocitem" href="#Copeland"><span>Copeland</span></a></li><li><a class="tocitem" href="#TOPSIS"><span>TOPSIS</span></a></li><li><a class="tocitem" href="#ELECTRE"><span>ELECTRE</span></a></li><li><a class="tocitem" href="#DEMATEL"><span>DEMATEL</span></a></li><li><a class="tocitem" href="#MOORA"><span>MOORA</span></a></li><li><a class="tocitem" href="#VIKOR"><span>VIKOR</span></a></li><li><a class="tocitem" href="#AHP"><span>AHP</span></a></li><li><a class="tocitem" href="#Grey-Relational-Analysis"><span>Grey Relational Analysis</span></a></li><li><a class="tocitem" href="#Non-dominated-Sorting"><span>Non-dominated Sorting</span></a></li><li><a class="tocitem" href="#SAW"><span>SAW</span></a></li><li><a class="tocitem" href="#ARAS"><span>ARAS</span></a></li><li><a class="tocitem" href="#WPM"><span>WPM</span></a></li><li><a class="tocitem" href="#WASPAS"><span>WASPAS</span></a></li><li><a class="tocitem" href="#EDAS"><span>EDAS</span></a></li><li><a class="tocitem" href="#MARCOS"><span>MARCOS</span></a></li><li><a class="tocitem" href="#MABAC"><span>MABAC</span></a></li><li><a class="tocitem" href="#MAIRCA"><span>MAIRCA</span></a></li><li><a class="tocitem" href="#COPRAS"><span>COPRAS</span></a></li><li><a class="tocitem" href="#PROMETHEE"><span>PROMETHEE</span></a></li><li><a class="tocitem" href="#CoCoSo"><span>CoCoSo</span></a></li><li><a class="tocitem" href="#Critic"><span>Critic</span></a></li><li><a class="tocitem" href="#CODAS"><span>CODAS</span></a></li><li><a class="tocitem" href="#MEREC"><span>MEREC</span></a></li><li><a class="tocitem" href="#PIV"><span>PIV</span></a></li><li><a class="tocitem" href="#PSI"><span>PSI</span></a></li><li><a class="tocitem" href="#ROV"><span>ROV</span></a></li><li><a class="tocitem" href="#MOOSRA"><span>MOOSRA</span></a></li><li><a class="tocitem" href="#SD"><span>SD</span></a></li><li><a class="tocitem" href="#SECA"><span>SECA</span></a></li><li><a class="tocitem" href="#LMAW"><span>LMAW</span></a></li><li><a class="tocitem" href="#LOPCOW"><span>LOPCOW</span></a></li><li><a class="tocitem" href="#OCRA"><span>OCRA</span></a></li><li><a class="tocitem" href="#TODIM"><span>TODIM</span></a></li></ul></li><li><a class="tocitem" href="../normalizations/">Normalization Methods</a></li><li><a class="tocitem" href="../game/">Game Solver</a></li><li><a class="tocitem" href="../dataenvelop/">Data Envelopment</a></li><li><a class="tocitem" href="../scdm/">SCDM</a></li><li><a class="tocitem" href="../utility/">Utility</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MCDM</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MCDM</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jbytecode/JMcDM" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jbytecode/JMcDM/blob/main/docs/src/mcdms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Multiple-Criteria-Decision-Making-Tools"><a class="docs-heading-anchor" href="#Multiple-Criteria-Decision-Making-Tools">Multiple Criteria Decision Making Tools</a><a id="Multiple-Criteria-Decision-Making-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Criteria-Decision-Making-Tools" title="Permalink"></a></h1><h2 id="Copeland"><a class="docs-heading-anchor" href="#Copeland">Copeland</a><a id="Copeland-1"></a><a class="docs-heading-anchor-permalink" href="#Copeland" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.Copeland.copeland" href="#JMcDM.Copeland.copeland"><code>JMcDM.Copeland.copeland</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    copeland(ordering_mat)</code></pre><p><strong>Arguments</strong></p><ul><li><code>ordering_mat</code>::Array{Int, 2}`: Ordering matrix.</li></ul><p><strong>Description</strong></p><p>The function takes an ordering matrix as input. Different ordering results are in columns. Orderings are in ascending order. The function returns the ranks. The alternative with rank  1 is the winner. </p><p><strong>Output</strong></p><ul><li><code>::Array{Int, 1}</code>: Vector of ranks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/copeland.jl#L64-L77">source</a></section><section><div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JMcDM

julia&gt; df = DataFrame(
    :c1 =&gt; [1.0, 2, 3, 4],
    :c2 =&gt; [5.0, 6, 7, 8],
    :c3 =&gt; [10.0, 11, 12, 13],
    :c4 =&gt; [20.0, 30, 40, 360],
)

julia&gt; weights = [0.25, 0.25, 0.25, 0.25]
julia&gt; fns = [maximum, maximum, maximum, maximum]

julia&gt; met = [
    PIVMethod(),
    PSIMethod(),
    ROVMethod(),
    SawMethod(),
    VikorMethod(),
    WaspasMethod(),
    WPMMethod(),
]

julia&gt; result = copeland(Matrix(df), w, fns, met)

4×8 DataFrame
 Row │ Piv    Psi    Rov    Saw    Vikor  Waspas  Wpm    Copeland 
     │ Int64  Int64  Int64  Int64  Int64  Int64   Int64  Int64    
─────┼────────────────────────────────────────────────────────────
   1 │     1      1      1      1      1       1      1         3
   2 │     2      2      2      2      2       2      2         1
   3 │     3      3      3      3      3       3      3        -1
   4 │     4      4      4      4      4       4      4        -3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/copeland.jl#L85-L123">source</a></section></article><h2 id="TOPSIS"><a class="docs-heading-anchor" href="#TOPSIS">TOPSIS</a><a id="TOPSIS-1"></a><a class="docs-heading-anchor-permalink" href="#TOPSIS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.Topsis.topsis" href="#JMcDM.Topsis.topsis"><code>JMcDM.Topsis.topsis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    topsis(decisionMat, weights, fns; normalization)</code></pre><p>Apply TOPSIS (Technique for Order of Preference by Similarity to Ideal Solution) method  for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of function that are either minimize or maximize.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>topsis() applies the TOPSIS method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::TopsisResult</code>: TopsisResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame();
julia&gt; df[:, :x] = Float64[9, 8, 7];
julia&gt; df[:, :y] = Float64[7, 7, 8];
julia&gt; df[:, :z] = Float64[6, 9, 6];
julia&gt; df[:, :q] = Float64[7, 6, 6];

julia&gt; w = Float64[4, 2, 6, 8];

julia&gt; df
3×4 DataFrame
 Row │ x        y        z        q       
     │ Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────
   1 │     9.0      7.0      6.0      7.0
   2 │     8.0      7.0      9.0      6.0
   3 │     7.0      8.0      6.0      6.0

julia&gt; fns = [maximum, maximum, maximum, maximum];
julia&gt; result = topsis(Matrix(df), w, fns);

julia&gt; result.bestIndex
2

julia&gt; result.scores
3-element Array{Float64,1}:
 0.38768695492211824
 0.6503238218850163
 0.08347670030339041</code></pre><p><strong>References</strong></p><p>Hwang, C.L.; Yoon, K. (1981). Multiple Attribute Decision Making: Methods and Applications. New York: Springer-Verlag</p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p><p>İşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/topsis.jl#L33-L92">source</a></section><section><div><pre><code class="language-julia hljs">    topsis(setting)</code></pre><p>Apply TOPSIS (Technique for Order of Preference by Similarity to Ideal Solution) method  for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>topsis() applies the TOPSIS method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::TopsisResult</code>: TopsisResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/topsis.jl#L141-L155">source</a></section></article><h2 id="ELECTRE"><a class="docs-heading-anchor" href="#ELECTRE">ELECTRE</a><a id="ELECTRE-1"></a><a class="docs-heading-anchor-permalink" href="#ELECTRE" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.ELECTRE.electre" href="#JMcDM.ELECTRE.electre"><code>JMcDM.ELECTRE.electre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    electre(decisionMat, weights, fns; normalization)</code></pre><p>Apply ELECTRE (ELimination Et Choice Translating REality) method  for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of function that are either minimize or maximize.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>electre() applies the ELECTRE method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized. C and D values are used to determine the best strategy. If the strategy with the highest C value  is same as the strategy with the lowest D value than the solution is unique. Otherwise, two strategies  are reported as the solution. </p><p><strong>Output</strong></p><ul><li><code>::ElectreResult</code>: ElectreResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w =  [0.110, 0.035, 0.379, 0.384, 0.002, 0.002, 0.010, 0.077];
julia&gt; Amat = [
      100 92 10 2 80 70 95 80 ;
      80  70 8  4 100 80 80 90 ;
      90 85 5 0 75 95 70 70 ; 
      70 88 20 18 60 90 95 85
    ];

julia&gt; fns = [maximum for i in 1:8];
julia&gt; result = electre(Amat, w, fns)


julia&gt; result.bestIndex
(4,)

julia&gt; result.C
4-element Array{Float64,1}:
  0.3693693693693696
  0.01501501501501501
 -2.473473473473473
  2.0890890890890894

julia&gt; result.D
4-element Array{Float64,1}:
  0.1914244325928971
 -0.19039293350192432
  2.884307608766315
 -2.885339107857288</code></pre><p><strong>References</strong></p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/electre.jl#L33-L89">source</a></section><section><div><pre><code class="language-julia hljs">    electre(setting)</code></pre><p>Apply ELECTRE (ELimination Et Choice Translating REality) method  for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>electre() applies the ELECTRE method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized. C and D values are used to determine the best strategy. If the strategy with the highest C value  is same as the strategy with the lowest D value than the solution is unique. Otherwise, two strategies  are reported as the solution. </p><p><strong>Output</strong></p><ul><li><code>::ElectreResult</code>: ElectreResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/electre.jl#L208-L225">source</a></section></article><h2 id="DEMATEL"><a class="docs-heading-anchor" href="#DEMATEL">DEMATEL</a><a id="DEMATEL-1"></a><a class="docs-heading-anchor-permalink" href="#DEMATEL" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.DEMATEL.dematel" href="#JMcDM.DEMATEL.dematel"><code>JMcDM.DEMATEL.dematel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    dematel(comparisonMat; threshold = nothing)</code></pre><p>Apply Dematel for a given comparison matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>comparisonMat::Matrix</code>: n × n Matrix of input values where n is the number of criteria. Values are either 0, 1, 2, 3, or 4 which indicate the level of importance of the ith criterion relative to the jth criterion.</li><li><code>threshold::Union{Nothing, Float64}</code>: Optional threshold used in calculating values of influence matrix. It is calculated when the argument is omitted. </li></ul><p><strong>Description</strong></p><p>dematel() applies the Dematel method to calculate criteria weights, possibly for use in another multi-criteria decision making tool.</p><p><strong>Output</strong></p><ul><li><code>::DematelResult</code>: DematelResult object that holds many results including weights for each single criterion.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; K = [
        0 3 0 2 0 0 0 0 3 0;
        3 0 0 0 0 0 0 0 0 2;
        4 1 0 2 1 3 1 2 3 2;
        4 1 4 0 1 2 0 1 0 0;
        3 2 3 1 0 3 0 2 0 0;
        4 1 4 4 0 0 0 1 1 3;
        3 0 0 0 0 2 0 0 0 0;
        3 0 4 3 2 3 1 0 0 0;
        4 3 2 0 0 1 0 0 0 2;
        2 1 0 0 0 0 0 0 3 0
    ];

julia&gt; result = dematel(K);

julia&gt; result.weights
10-element Array{Float64,1}:
 0.1686568559124561
 0.07991375718719543
 0.14006200243438863
 0.10748052790517183
 0.08789022388276985
 0.12526272598854982
 0.03067915023486491
 0.10489168834828348
 0.092654758940811
 0.06250830916550884</code></pre><p><strong>References</strong></p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/dematel.jl#L24-L74">source</a></section></article><h2 id="MOORA"><a class="docs-heading-anchor" href="#MOORA">MOORA</a><a id="MOORA-1"></a><a class="docs-heading-anchor-permalink" href="#MOORA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.MOORA.moora" href="#JMcDM.MOORA.moora"><code>JMcDM.MOORA.moora</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    moora_ratio(decisionMat, weights, fns; method = :reference, normalization)</code></pre><p>Apply MOORA (Multi-Objective Optimization By Ratio Analysis) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of function that are either maximum or minimum.</li><li><code>method::Symbol</code>: Either <code>:reference</code> or <code>:ratio</code>. By default, it is <code>:reference</code>.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>moora() applies the MOORA method to rank n strategies subject to m criteria which are supposed to be  either maximized or minimized. This method has two different versions. The method parameter determines the method used. It is <code>:reference</code> by default. For the other version, it can be set to <code>:ratio</code>.  </p><p><strong>Output</strong></p><ul><li><code>::MooraResult</code>: MooraResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>References</strong></p><p>KUNDAKCI, Nilsen. &quot;Combined multi-criteria decision making approach based on MACBETH  and MULTI-MOORA methods.&quot; Alphanumeric Journal 4.1 (2016): 17-26.</p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p><p>İşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/moora.jl#L217-L248">source</a></section><section><div><pre><code class="language-julia hljs">    moora(setting; method = :reference)</code></pre><p>Apply MOORA (Multi-Objective Optimization By Ratio Analysis) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li><li><code>method::Symbol</code>: Either <code>:reference</code> or <code>:ratio</code>. By default, it is <code>:reference</code>.</li></ul><p><strong>Description</strong></p><p>moora() applies the MOORA method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MooraResult</code>: MooraResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/moora.jl#L268-L282">source</a></section></article><h2 id="VIKOR"><a class="docs-heading-anchor" href="#VIKOR">VIKOR</a><a id="VIKOR-1"></a><a class="docs-heading-anchor-permalink" href="#VIKOR" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.VIKOR.vikor" href="#JMcDM.VIKOR.vikor"><code>JMcDM.VIKOR.vikor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    vikor(decisionMat, weights, fns; v = 0.5, normalization)</code></pre><p>Apply VIKOR (VlseKriterijumska Optimizcija I Kaompromisno Resenje in Serbian) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of function that are either maximum or minimum.</li><li><code>v::Float64</code>: Optional algorithm parameter. Default is 0.5.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function. Default is Normalizations.inversemaxminrangenormalization.</li></ul><p><strong>Description</strong></p><p>vikor() applies the VIKOR method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::VikorResult</code>: VikorResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Amat = [
             100 92 10 2 80 70 95 80 ;
             80  70 8  4 100 80 80 90 ;
             90 85 5 0 75 95 70 70 ; 
             70 88 20 18 60 90 95 85
           ];


julia&gt; fns = [maximum, maximum, maximum, maximum, maximum, maximum, maximum, maximum];

julia&gt; result = vikor(Amat, w, fns);

julia&gt; result.scores
4-element Array{Float64,1}:
  0.7489877763052237
  0.7332093914796731
  1.0
  0.0

julia&gt; result.bestIndex
4
</code></pre><p><strong>References</strong></p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/vikor.jl#L30-L77">source</a></section><section><div><pre><code class="language-julia hljs">    vikor(setting; v = 0.5)</code></pre><p>Apply VIKOR (VlseKriterijumska Optimizcija I Kaompromisno Resenje in Serbian) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li><li><code>v::Float64</code>: Optional algorithm parameter. Default is 0.5.</li></ul><p><strong>Description</strong></p><p>vikor() applies the VIKOR method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::VikorResult</code>: VikorResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/vikor.jl#L120-L134">source</a></section></article><h2 id="AHP"><a class="docs-heading-anchor" href="#AHP">AHP</a><a id="AHP-1"></a><a class="docs-heading-anchor-permalink" href="#AHP" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.AHP.ahp" href="#JMcDM.AHP.ahp"><code>JMcDM.AHP.ahp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AHP(comparisonMatrixList, criteriaComparisonMatrix)</code></pre><p>Apply AHP (Analytical Hierarchy Process) for a given list of comparison matrices and criteria comparison matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>comparisonMatrixList::Array{Matrix,1}</code>: Array of comparison matrices for all of the criteria. </li><li><code>criteriaComparisonMatrix::Matrix</code>: Criteria comparison matrix for AHP (Comparison of columns). </li></ul><p><strong>Description</strong></p><p>AHP is based on subjective comparison between criteria. The success of the method highly depends on  consistency of these comparison. The method test the consistency first. At the next step, weights are  calculated. The ordering of rows is determined by these weights.</p><p><strong>Output</strong></p><ul><li><code>::AHPResult</code>: AhpResult object that holds multiple outputs including calculated weights and scores.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; K
8×8 Array{Float64,2}:
 1.0       7.0  0.2    0.125     0.5   0.333333  0.2       1.0
 0.142857  1.0  0.125  0.111111  0.25  0.2       0.111111  0.125
 5.0       8.0  1.0    0.333333  4.0   2.0       1.0       1.0
 8.0       9.0  3.0    1.0       7.0   5.0       3.0       3.0
 2.0       4.0  0.25   0.142857  1.0   0.5       0.2       0.2
 3.0       5.0  0.5    0.2       2.0   1.0       0.333333  0.333333
 5.0       9.0  1.0    0.333333  5.0   3.0       1.0       1.0
 1.0       8.0  1.0    0.333333  5.0   3.0       1.0       1.0

julia&gt; A1
4×4 Array{Float64,2}:
 1.0       3.0  0.2       2.0
 0.333333  1.0  0.142857  0.333333
 5.0       7.0  1.0       4.0
 0.5       3.0  0.25      1.0

julia&gt; A2
4×4 Array{Float64,2}:
 1.0   0.5       4.0       5.0
 2.0   1.0       6.0       7.0
 0.25  0.166667  1.0       3.0
 0.2   0.142857  0.333333  1.0

julia&gt; A3
4×4 Array{Float64,2}:
 1.0       0.5  0.166667  3.0
 2.0       1.0  0.25      5.0
 6.0       4.0  1.0       9.0
 0.333333  0.2  0.111111  1.0

julia&gt; A4
4×4 Array{Float64,2}:
 1.0       7.0  0.25      2.0
 0.142857  1.0  0.111111  0.2
 4.0       9.0  1.0       5.0
 0.5       5.0  0.2       1.0

julia&gt; A5
4×4 Array{Float64,2}:
 1.0       6.0  2.0   3.0
 0.166667  1.0  0.25  0.333333
 0.5       4.0  1.0   2.0
 0.333333  3.0  0.5   1.0

julia&gt; A6
4×4 Array{Float64,2}:
 1.0  0.25  0.5  0.142857
 4.0  1.0   2.0  0.333333
 2.0  0.5   1.0  0.2
 7.0  3.0   5.0  1.0

julia&gt; A7
4×4 Array{Float64,2}:
 1.0       3.0   7.0  1.0
 0.333333  1.0   4.0  0.333333
 0.142857  0.25  1.0  0.142857
 1.0       3.0   7.0  1.0

julia&gt; A8
4×4 Array{Float64,2}:
 1.0    2.0       5.0       8.0
 0.5    1.0       3.0       6.0
 0.2    0.333333  1.0       3.0
 0.125  0.166667  0.333333  1.0

julia&gt; as = hcat(A1, A2, A3, A4, A5, A6, A7, A8);
julia&gt; result = ahp(as, K);
julia&gt; result.bestIndex
3
julia&gt; result.scores
4-element Array{Float64,1}:
 0.2801050163111839
 0.14822726478768022
 0.3813036392434616
 0.19036407965767424</code></pre><p><strong>References</strong></p><p>Saaty, Thomas L. &quot;Decision making with the analytic hierarchy process.&quot; International journal of services sciences 1.1 (2008): 83-98.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/ahp.jl#L164-L265">source</a></section></article><h2 id="Grey-Relational-Analysis"><a class="docs-heading-anchor" href="#Grey-Relational-Analysis">Grey Relational Analysis</a><a id="Grey-Relational-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Grey-Relational-Analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.GREY.grey" href="#JMcDM.GREY.grey"><code>JMcDM.GREY.grey</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    grey(decisionMat, weights, fs; zeta, normalization)

Perform GRA (Grey Relational Analysis) for a given decision matrix and weights.</code></pre><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of decision matrix in type of DataFrame. </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights for criteria.</li><li><code>fs::Array{Function, 1}</code>: m-vector of functions that are either maximize or minimize for each single criterion.</li><li><code>zeta::Float64</code>: zeta parameter for the algorithm. The default is 0.5.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>Applies GRA (Grey Relational Analysis).</p><p><strong>Output</strong></p><ul><li><code>::GreyResult</code>: GreyResult object that holds many values including ordering of strategies or candidates and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Decision matrix of 5 candidates and 6 criteria.
julia&gt; df = DataFrame(
               :K1 =&gt; [105000.0, 120000, 150000, 115000, 135000],
               :K2 =&gt; [105.0, 110, 120, 105, 115],
               :K3 =&gt; [10.0, 15, 12, 20, 15],
               :K4 =&gt; [4.0, 4, 3, 4, 5],
               :K5 =&gt; [300.0, 500, 550, 600, 400],
               :K6 =&gt; [10.0, 8, 12, 9, 9]
        )
5×6 DataFrame
 Row │ K1        K2       K3       K4       K5       K6      
     │ Float64   Float64  Float64  Float64  Float64  Float64 
─────┼───────────────────────────────────────────────────────
   1 │ 105000.0    105.0     10.0      4.0    300.0     10.0
   2 │ 120000.0    110.0     15.0      4.0    500.0      8.0
   3 │ 150000.0    120.0     12.0      3.0    550.0     12.0
   4 │ 115000.0    105.0     20.0      4.0    600.0      9.0
   5 │ 135000.0    115.0     15.0      5.0    400.0      9.0

julia&gt; # Direction of optimization for each single criterion
julia&gt; functionlist = [minimum, maximum, minimum, maximum, maximum, minimum];

julia&gt; # Weights
julia&gt; w = [0.05, 0.20, 0.10, 0.15, 0.10, 0.40];

julia&gt; result = grey(Matrix(df), w, functionlist);

julia&gt; result.scores
5-element Array{Float64,1}:
 0.525
 0.7007142857142857
 0.5464285714285715
 0.5762820512820512
 0.650952380952381

julia&gt; result.bestIndex
2</code></pre><p><strong>References</strong></p><p>İşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/grey.jl#L32-L95">source</a></section><section><div><pre><code class="language-julia hljs">    grey(setting; zeta)

Perform GRA (Grey Relational Analysis) for a given decision matrix and weights.</code></pre><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li><li><code>zeta::Float64</code>: zeta parameter for the algorithm. The default is 0.5.</li></ul><p><strong>Description</strong></p><p>Applies GRA (Grey Relational Analysis).</p><p><strong>Output</strong></p><ul><li><code>::GreyResult</code>: GreyResult object that holds many values including ordering of strategies or candidates and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/grey.jl#L186-L200">source</a></section></article><h2 id="Non-dominated-Sorting"><a class="docs-heading-anchor" href="#Non-dominated-Sorting">Non-dominated Sorting</a><a id="Non-dominated-Sorting-1"></a><a class="docs-heading-anchor-permalink" href="#Non-dominated-Sorting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.NDS.nds" href="#JMcDM.NDS.nds"><code>JMcDM.NDS.nds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nds(data, fns)

Sort multidimensional data using non-dominated sorting algorithm.</code></pre><p><strong>Arguments</strong></p><ul><li><code>data::Matrix</code>: n x k desicion matrix with n cases and k criteria.</li><li><code>fns::Array{&lt;:Function, 1}</code>: Vector of functions with elements of maximum or minimum.</li></ul><p><strong>Output</strong></p><ul><li><code>::NDSResult</code>: NDSResult object that holds multiple outputs including ranks and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"> julia&gt; cases = [
               1.0 2.0 3.0;
               2.0 1.0 3.0;
               1.0 3.0 2.0;
               4.0 5.0 6.0
           ];


julia&gt; result = nds(cases, [maximum, maximum, maximum]);

julia&gt; result.ranks
4-element Array{Int64,1}:
 0
 0
 0
 3

julia&gt; result.bestIndex
4 </code></pre><p><strong>References</strong></p><p>Deb, Kalyanmoy, et al. &quot;A fast elitist non-dominated sorting genetic algorithm for multi-objective optimization: NSGA-II.&quot;  International conference on parallel problem solving from nature. Springer, Berlin, Heidelberg, 2000.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/nds.jl#L96-L135">source</a></section></article><h2 id="SAW"><a class="docs-heading-anchor" href="#SAW">SAW</a><a id="SAW-1"></a><a class="docs-heading-anchor-permalink" href="#SAW" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.SAW.saw" href="#JMcDM.SAW.saw"><code>JMcDM.SAW.saw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    saw(decisionMat, weights, fns; normalization)</code></pre><p>Apply SAW (Simple Additive Weighting) method for a given matrix and weights. This method also known as WSM (Weighted Sum Model)</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns. </li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>saw() applies the SAW method to rank n strategies subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::SawResult</code>: SawResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [4.0  7  3  2  2  2  2;
                 4.0  4  6  4  4  3  7;
                 7.0  6  4  2  5  5  3;
                 3.0  2  5  3  3  2  5;
                 4.0  2  2  5  5  3  6];

julia&gt; fns = [maximum for i in 1:7];

julia&gt; weights = [0.283, 0.162, 0.162, 0.07, 0.085, 0.162, 0.076];

julia&gt; result = saw(decmat, weights, fns);

julia&gt; result.scores
5-element Array{Float64,1}:
 0.5532285714285714
 0.7134857142857142
 0.8374285714285714
 0.5146571428571429
 0.5793428571428572

julia&gt; result.bestIndex
3</code></pre><p><strong>References</strong></p><p>Afshari, Alireza, Majid Mojahed, and Rosnah Mohd Yusuff. &quot;Simple additive weighting approach to  personnel selection problem.&quot; International Journal of Innovation, Management and Technology  1.5 (2010): 511.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/saw.jl#L30-L79">source</a></section><section><div><pre><code class="language-julia hljs">    saw(setting)</code></pre><p>Apply SAW (Simple Additive Weighting) method for a given matrix and weights. This method also known as WSM (Weighted Sum Model)</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>saw() applies the SAW method to rank n strategies subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::SawResult</code>: SawResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/saw.jl#L110-L125">source</a></section></article><h2 id="ARAS"><a class="docs-heading-anchor" href="#ARAS">ARAS</a><a id="ARAS-1"></a><a class="docs-heading-anchor-permalink" href="#ARAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.ARAS.aras" href="#JMcDM.ARAS.aras"><code>JMcDM.ARAS.aras</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aras(decisionMat, weights, fs; normalization)</code></pre><p>Apply ARAS (Additive Ratio ASsessment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fs::Array{&lt;:Function,1}</code>: m-vector of type of criteria. The benefit criteria shown with &quot;maximum&quot;, and the cost criteria shown with &quot;minimum&quot;.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>aras() applies the ARAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::ARASResult</code>: ARASResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(
    :K1 =&gt; [105000.0, 120000, 150000, 115000, 135000],
    :K2 =&gt; [105.0, 110, 120, 105, 115],
    :K3 =&gt; [10.0, 15, 12, 20, 15],
    :K4 =&gt; [4.0, 4, 3, 4, 5],
    :K5 =&gt; [300.0, 500, 550, 600, 400],
    :K6 =&gt; [10.0, 8, 12, 9, 9]
)
julia&gt; df
5×6 DataFrame
 Row │ K1        K2       K3       K4       K5       K6      
     │ Float64   Float64  Float64  Float64  Float64  Float64 
─────┼───────────────────────────────────────────────────────
   1 │ 105000.0    105.0     10.0      4.0    300.0     10.0
   2 │ 120000.0    110.0     15.0      4.0    500.0      8.0
   3 │ 150000.0    120.0     12.0      3.0    550.0     12.0
   4 │ 115000.0    105.0     20.0      4.0    600.0      9.0
   5 │ 135000.0    115.0     15.0      5.0    400.0      9.0

julia&gt; result = aras(Matrix(df), w, fs);
julia&gt; result.bestIndex
2
julia&gt; result.scores
5-element Array{Float64,1}:
 0.8142406768388222
 0.8928861957614441
 0.764157900073527
 0.8422546181927358
 0.8654063509472654</code></pre><p><strong>References</strong></p><p>Zavadskas, E. K., &amp; Turskis, Z. (2010). A new additive ratio assessment (ARAS) method in multicriteria decision‐making. Technological and Economic Development of Economy, 16(2), 159-172. Yıldırım, B. F. (2015). &quot;Çok Kriterli Karar Verme Problemlerinde ARAS Yöntemi&quot;. Kafkas Üniversitesi İktisadi ve İdari Bilimler Fakültesi Dergisi, 6 (9), 285-296. http://dx.doi.org/10.18025/kauiibf.65151</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/aras.jl#L31-L82">source</a></section><section><div><pre><code class="language-julia hljs">aras(setting)</code></pre><p>Apply ARAS (Additive Ratio ASsessment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>aras() applies the ARAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::ARASResult</code>: ARASResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/aras.jl#L136-L148">source</a></section></article><h2 id="WPM"><a class="docs-heading-anchor" href="#WPM">WPM</a><a id="WPM-1"></a><a class="docs-heading-anchor-permalink" href="#WPM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.WPM.wpm" href="#JMcDM.WPM.wpm"><code>JMcDM.WPM.wpm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    wpm(decisionMat, weights, fns)</code></pre><p>Apply WPM (Weighted Product Method) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alterntives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns. </li><li><code>normalization{&lt;:Function}</code>: Optional normalization function. </li></ul><p><strong>Description</strong></p><p>wpm() applies the WPM method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::WPMResult</code>: WPMResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [3        12.5        2        120        14        3;
       5        15        3        110        38        4;
       3        13        2        120        19        3;
       4        14        2        100        31        4;
       3        15        1.5        125        40        4]
5×6 Array{Float64,2}:
 3.0  12.5  2.0  120.0  14.0  3.0
 5.0  15.0  3.0  110.0  38.0  4.0
 3.0  13.0  2.0  120.0  19.0  3.0
 4.0  14.0  2.0  100.0  31.0  4.0
 3.0  15.0  1.5  125.0  40.0  4.0


julia&gt; weights = [0.221, 0.159, 0.175, 0.127, 0.117, 0.201];

julia&gt; fns = [maximum, minimum, minimum, maximum, minimum, maximum];

julia&gt; result = wpm(decmat, weights, fns);

julia&gt; result.scores
5-element Array{Float64,1}:
 0.7975224331331252
 0.7532541470584717
 0.7647463553356331
 0.7873956894790834
 0.7674278741781709

julia&gt; result.bestIndex
1</code></pre><p><strong>References</strong></p><p>Zavadskas, E. K., Turskis, Z., Antucheviciene, J., &amp; Zakarevicius, A. (2012). Optimization of Weighted Aggregated Sum Product Assessment. Elektronika Ir Elektrotechnika, 122(6), 3-6. https://doi.org/10.5755/j01.eee.122.6.1810</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/wpm.jl#L30-L83">source</a></section><section><div><pre><code class="language-julia hljs">    wpm(setting)</code></pre><p>Apply WPM (Weighted Product Method) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>wpm() applies the WPM method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::WPMResult</code>: WPMResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/wpm.jl#L128-L142">source</a></section></article><h2 id="WASPAS"><a class="docs-heading-anchor" href="#WASPAS">WASPAS</a><a id="WASPAS-1"></a><a class="docs-heading-anchor-permalink" href="#WASPAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.WASPAS.waspas" href="#JMcDM.WASPAS.waspas"><code>JMcDM.WASPAS.waspas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    waspas(decisionMat, weights, fns; lambda = 0.5, normalization)</code></pre><p>Apply WASPAS (Weighted Aggregated Sum Product ASsessment ) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alterntives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns.</li><li><code>lambda::Float64</code>: joint criterion. 0&lt;=lambda&lt;=1, default=0.5.</li><li><code>normalization{&lt;:Function}</code>: Normalization function. Default is Normalizations.dividebycolumnmaxminnormalization.</li></ul><p><strong>Description</strong></p><p>waspas() applies the WASPAS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::WASPASResult</code>: WASPASResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [3        12.5        2        120        14        3;
       5        15        3        110        38        4;
       3        13        2        120        19        3;
       4        14        2        100        31        4;
       3        15        1.5        125        40        4]
5×6 Array{Float64,2}:
 3.0  12.5  2.0  120.0  14.0  3.0
 5.0  15.0  3.0  110.0  38.0  4.0
 3.0  13.0  2.0  120.0  19.0  3.0
 4.0  14.0  2.0  100.0  31.0  4.0
 3.0  15.0  1.5  125.0  40.0  4.0


julia&gt; weights = [0.221, 0.159, 0.175, 0.127, 0.117, 0.201];

julia&gt; fns = [maximum, minimum, minimum, maximum, minimum, maximum];

julia&gt; lambda = 0.5;

julia&gt; result = wpm(decmat, weights, fns, lambda);

julia&gt; result.scores
5-element Array{Float64,1}:
 0.8050212165665626
 0.7750597051081832
 0.770180748518019
 0.7964243424353943
 0.7882389370890854

 julia&gt; result.bestIndex
 1</code></pre><p><strong>References</strong></p><p>Zavadskas, E. K., Turskis, Z., Antucheviciene, J., &amp; Zakarevicius, A. (2012). Optimization of Weighted Aggregated Sum Product Assessment. Elektronika Ir Elektrotechnika, 122(6), 3-6. https://doi.org/10.5755/j01.eee.122.6.1810 Aytaç Adalı, E. &amp; Tuş Işık, A.. (2017). Bir Tedarikçi Seçim Problemi İçin SWARA ve WASPAS Yöntemlerine Dayanan Karar Verme Yaklaşımı. International Review of Economics and Management, 5 (4) , 56-77. DOI: 10.18825/iremjournal.335408</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/waspas.jl#L31-L88">source</a></section><section><div><pre><code class="language-julia hljs">    waspas(setting; lambda = 0.5)</code></pre><p>Apply WASPAS (Weighted Aggregated Sum Product ASsessment ) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li><li><code>lambda::Float64</code>: joint criterion. 0&lt;=lambda&lt;=1, default=0.5.</li></ul><p><strong>Description</strong></p><p>waspas() applies the WASPAS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::WASPASResult</code>: WASPASResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/waspas.jl#L151-L166">source</a></section></article><h2 id="EDAS"><a class="docs-heading-anchor" href="#EDAS">EDAS</a><a id="EDAS-1"></a><a class="docs-heading-anchor-permalink" href="#EDAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.EDAS.edas" href="#JMcDM.EDAS.edas"><code>JMcDM.EDAS.edas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    edas(decisionMat, weights, fns)</code></pre><p>Apply EDAS (Evaluation based on Distance from Average Solution) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alterntives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>edas() applies the EDAS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::EDASResult</code>: EDASResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [5000 5 5300 450;
       4500 5 5000 400;
       4500 4 4700 400;
       4000 4 4200 400;
       5000 4 7100 500;
       5000 5 5400 450;
       5500 5 6200 500;
       5000 4 5800 450]
8×4 Array{Int64,2}:
 5000  5  5300  450
 4500  5  5000  400
 4500  4  4700  400
 4000  4  4200  400
 5000  4  7100  500
 5000  5  5400  450
 5500  5  6200  500
 5000  4  5800  450


julia&gt; weights = [0.25, 0.25, 0.25, 0.25];

julia&gt; fns = [maximum, maximum, minimum, minimum];

julia&gt; result = edas(decmat, weights, fns);

julia&gt; result.scores
8-element Array{Float64,1}:
 0.7595941163602383
 0.8860162461306114
 0.6974721951442592
 0.739657763190231
 0.05908329207449442
 0.7318326305342363
 0.6416913873322523
 0.38519414045559647

julia&gt; result.bestIndex
2</code></pre><p><strong>References</strong></p><p>Keshavarz Ghorabaee, M., Zavadskas, E. K., Olfat, L., &amp; Turskis, Z. (2015). Multi-criteria inventory classification using a new method of evaluation based on distance from average solution (EDAS). Informatica, 26(3), 435-451.</p><p>Ulutaş, A. (2017). EDAS Yöntemi Kullanılarak Bir Tekstil Atölyesi İçin Dikiş Makinesi Seçimi. İşletme Araştırmaları Dergisi, 9(2), 169-183.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/edas.jl#L30-L95">source</a></section><section><div><pre><code class="language-julia hljs">    edas(setting)</code></pre><p>Apply EDAS (Evaluation based on Distance from Average Solution) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>edas() applies the EDAS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::EDASResult</code>: EDASResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/edas.jl#L166-L180">source</a></section></article><h2 id="MARCOS"><a class="docs-heading-anchor" href="#MARCOS">MARCOS</a><a id="MARCOS-1"></a><a class="docs-heading-anchor-permalink" href="#MARCOS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.MARCOS.marcos" href="#JMcDM.MARCOS.marcos"><code>JMcDM.MARCOS.marcos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    marcos(decisionMat, weights, fns)</code></pre><p>Apply MARCOS (Measurement Alternatives and Ranking according to COmpromise Solution) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alterntives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>marcos() applies the MARCOS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MARCOSResult</code>: MARCOSResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [8.675 8.433 8.000 7.800 8.025 8.043;
       8.825 8.600 7.420 7.463 7.825 8.229;
       8.325 7.600 8.040 7.700 7.925 7.600;
       8.525 8.667 7.180 7.375 7.750 8.071]
4×6 Array{Float64,2}:
 8.675  8.433  8.0   7.8    8.025  8.043
 8.825  8.6    7.42  7.463  7.825  8.229
 8.325  7.6    8.04  7.7    7.925  7.6
 8.525  8.667  7.18  7.375  7.75   8.071


julia&gt; weights = [0.1901901901901902 , 0.15915915915915918 , 0.19819819819819823, 0.1901901901901902, 0.15115115115115116, 0.11111111111111112];

julia&gt; fns = [maximum, maximum, maximum, maximum, maximum, maximum];

julia&gt; result = marcos(decmat, weights, fns);

julia&gt; result.scores
4-element Array{Float64,1}:
 0.6848657890705123
 0.6727670074308345
 0.6625969531206817
 0.6611030275027843

julia&gt; result.bestIndex
1</code></pre><p><strong>References</strong></p><p>Stević, Z., Pamučar, D., Puška, A., Chatterjee, P., Sustainable supplier selection in healthcare industries using a new MCDM method: Measurement Alternatives and Ranking according to COmpromise Solution (MARCOS), Computers &amp; Industrial Engineering (2019), doi: https://doi.org/10.1016/j.cie.2019.106231</p><p>Puška, A., Stojanović, I., Maksimović, A., &amp; Osmanović, N. (2020). Evaluation software of project management used measurement of alternatives and ranking according to compromise solution (MARCOS) method. Operational Research in Engineering Sciences: Theory and Applications, 3(1), 89-102.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/marcos.jl#L22-L73">source</a></section><section><div><pre><code class="language-julia hljs">    marcos(setting)</code></pre><p>Apply MARCOS (Measurement Alternatives and Ranking according to COmpromise Solution) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting </li></ul><p><strong>Description</strong></p><p>marcos() applies the MARCOS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MARCOSResult</code>: MARCOSResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/marcos.jl#L140-L154">source</a></section></article><h2 id="MABAC"><a class="docs-heading-anchor" href="#MABAC">MABAC</a><a id="MABAC-1"></a><a class="docs-heading-anchor-permalink" href="#MABAC" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.MABAC.mabac" href="#JMcDM.MABAC.mabac"><code>JMcDM.MABAC.mabac</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    mabac(decisionMat, weights, fns; normalization)</code></pre><p>Apply MABAC (Multi-Attributive Border Approximation area Comparison) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns. </li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>mabac() applies the MABAC method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MABACResult</code>: MABACResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [2 1 4 7 6 6 7 3000;
       4 1 5 6 7 7 6 3500;
       3 2 6 6 5 6 8 4000;
       5 1 5 7 6 7 7 3000;
       4 2 5 6 7 7 6 3000;
       3 2 6 6 6 6 6 3500]
6×8 
Array{Int64,2}:
 2  1  4  7  6  6  7  3000
 4  1  5  6  7  7  6  3500
 3  2  6  6  5  6  8  4000
 5  1  5  7  6  7  7  3000
 4  2  5  6  7  7  6  3000
 3  2  6  6  6  6  6  3500


julia&gt; weights = [0.293, 0.427, 0.067, 0.027, 0.053, 0.027, 0.053, 0.053];

julia&gt; fns = [maximum, maximum, maximum, maximum, maximum, maximum, maximum, minimum];

julia&gt; result = mabac(decmat, weights, fns);

julia&gt; result.scores
6-element Array{Float64,1}:
 -0.3113160790692055
 -0.10898274573587217
  0.2003505875974611
  0.0421839209307945
  0.3445172542641278
  0.2003505875974611

julia&gt; result.bestIndex
5</code></pre><p><strong>References</strong></p><p>Pamučar, D., &amp; Ćirović, G. (2015). The selection of transport and handling resources in logistics centers using Multi-Attributive Border Approximation area Comparison (MABAC). Expert Systems with Applications, 42(6), 3016–3028. doi:10.1016/j.eswa.2014.11.057</p><p>Ulutaş, A. (2019). Entropi ve MABAC yöntemleri ile personel seçimi. OPUS–International Journal of Society Researches, 13(19), 1552-1573. DOI: 10.26466/opus.580456</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/mabac.jl#L32-L92">source</a></section><section><div><pre><code class="language-julia hljs">    mabac(setting)</code></pre><p>Apply MABAC (Multi-Attributive Border Approximation area Comparison) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>mabac() applies the MABAC method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MABACResult</code>: MABACResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/mabac.jl#L151-L165">source</a></section></article><h2 id="MAIRCA"><a class="docs-heading-anchor" href="#MAIRCA">MAIRCA</a><a id="MAIRCA-1"></a><a class="docs-heading-anchor-permalink" href="#MAIRCA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.MAIRCA.mairca" href="#JMcDM.MAIRCA.mairca"><code>JMcDM.MAIRCA.mairca</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    mairca(decisionMat, weights, fns; normalization)</code></pre><p>Apply MAIRCA (Multi Attributive Ideal-Real Comparative Analysis) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns. </li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>mairca() applies the MAIRCA method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MAIRCAResult</code>: MAIRCAResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [6.952 8.000 6.649 7.268 8.000 7.652 6.316;
       7.319 7.319 6.604 7.319 8.000 7.652 5.313;
       7.000 7.319 7.652 6.952 7.652 6.952 4.642;
       7.319 6.952 6.649 7.319 7.652 6.649 5.000]
4×7 Array{Float64,2}:
 6.952  8.0    6.649  7.268  8.0    7.652  6.316
 7.319  7.319  6.604  7.319  8.0    7.652  5.313
 7.0    7.319  7.652  6.952  7.652  6.952  4.642
 7.319  6.952  6.649  7.319  7.652  6.649  5.0


julia&gt; weights = [0.172, 0.165, 0.159, 0.129, 0.112, 0.122, 0.140];

julia&gt; fns = [maximum, maximum, maximum, maximum, maximum, maximum, minimum];

julia&gt; result = mairca(decmat, weights, fns);

julia&gt; result.scores
4-element Array{Float64,1}:
 0.12064543054088471
 0.08066456363291889
 0.14586265389012484
 0.14542366685864686

julia&gt; result.bestIndex
2</code></pre><p><strong>References</strong></p><p>Pamučar, D., Lukovac, V., Božanić, D., &amp; Komazec, N. (2018). Multi-criteria FUCOM-MAIRCA model for the evaluation of level crossings: case study in the Republic of Serbia. Operational Research in Engineering Sciences: Theory and Applications, 1(1), 108-129.</p><p>Ulutaş A.(2019),Swara Ve Mairca Yöntemleri İle Catering Firması Seçimi,BMIJ, (2019), 7(4): 1467-1479 http://dx.doi.org/10.15295/bmij.v7i4.1166</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/mairca.jl#L28-L81">source</a></section><section><div><pre><code class="language-julia hljs">    mairca(setting)</code></pre><p>Apply MAIRCA (Multi Attributive Ideal-Real Comparative Analysis) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>mairca() applies the MAIRCA method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MAIRCAResult</code>: MAIRCAResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/mairca.jl#L137-L151">source</a></section></article><h2 id="COPRAS"><a class="docs-heading-anchor" href="#COPRAS">COPRAS</a><a id="COPRAS-1"></a><a class="docs-heading-anchor-permalink" href="#COPRAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.COPRAS.copras" href="#JMcDM.COPRAS.copras"><code>JMcDM.COPRAS.copras</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copras(decisionMat, weights, fs; normalization)</code></pre><p>Apply COPRAS (COmplex PRoportional ASsesment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fs::Array{&lt;:Function,1}</code>: m-vector of type of criteria. The benefit criteria shown with &quot;maximum&quot;, and the cost criteria shown with &quot;minimum&quot;.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>copras() applies the COPRAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::COPRASResult</code>: COPRASResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [2.50 240 57 45 1.10 0.333333;
       2.50 285 60 75 4.00 0.428571;
       4.50 320 100 65 7.50 1.111111;
       4.50 365 100 90 7.50 1.111111;
       5.00 400 100 90 11.00 1.111111;
       2.50 225 60 45 1.10 0.333333;
       2.50 270 57 60 4.00 0.428571;
       4.50 330 100 70 7.50 1.111111;
       4.50 365 100 80 7.50 1.111111;
       5.00 380 110 65 8.00 1.111111;
       2.50 285 65 80 4.00 0.400000;
       4.00 280 75 65 4.00 0.400000;
       4.50 365 102 95 7.50 1.111111;
       4.50 400 102 95 7.50 1.111111;
       6.00 450 110 95 11.00 1.176471;
       6.00 510 110 105 11.00 1.176471;
       6.00 330 140 110 18.50 1.395349;
       2.50 240 65 80 4.00 0.400000;
       4.00 280 75 75 4.00 0.400000;
       4.50 355 102 95 7.50 1.111111;
       4.50 385 102 90 7.50 1.111111;
       5.00 385 114 95 7.50 1.000000;
       6.00 400 110 90 11.00 1.000000;
       6.00 480 110 95 15.00 1.000000;
       6.00 440 140 100 18.50 1.200000;
       6.00 500 140 100 18.50 1.200000;
       5.00 450 125 100 15.00 1.714286;
       6.00 500 150 125 18.50 1.714286;
       6.00 515 180 140 22.00 2.307692;
       7.00 550 200 150 30.00 2.307692;
       6.00 500 180 140 15.00 2.307692;
       6.00 500 180 140 18.50 2.307692;
       6.00 500 180 140 22.00 2.307692;
       7.00 500 180 140 30.00 2.307692;
       7.00 500 200 140 37.00 2.307692;
       7.00 500 200 140 45.00 2.307692;
       7.00 500 200 140 55.00 2.307692;
       7.00 500 200 140 75.00 2.307692]
38×6 Array{Float64,2}:
 2.5  240.0   57.0   45.0   1.1  0.333333
 2.5  285.0   60.0   75.0   4.0  0.428571
 4.5  320.0  100.0   65.0   7.5  1.11111
 4.5  365.0  100.0   90.0   7.5  1.11111
 5.0  400.0  100.0   90.0  11.0  1.11111
 2.5  225.0   60.0   45.0   1.1  0.333333
 2.5  270.0   57.0   60.0   4.0  0.428571
 4.5  330.0  100.0   70.0   7.5  1.11111
 4.5  365.0  100.0   80.0   7.5  1.11111
 5.0  380.0  110.0   65.0   8.0  1.11111
 2.5  285.0   65.0   80.0   4.0  0.4
 ⋮                               ⋮
 6.0  500.0  150.0  125.0  18.5  1.71429
 6.0  515.0  180.0  140.0  22.0  2.30769
 7.0  550.0  200.0  150.0  30.0  2.30769
 6.0  500.0  180.0  140.0  15.0  2.30769
 6.0  500.0  180.0  140.0  18.5  2.30769
 6.0  500.0  180.0  140.0  22.0  2.30769
 7.0  500.0  180.0  140.0  30.0  2.30769
 7.0  500.0  200.0  140.0  37.0  2.30769
 7.0  500.0  200.0  140.0  45.0  2.30769
 7.0  500.0  200.0  140.0  55.0  2.30769
 7.0  500.0  200.0  140.0  75.0  2.30769

julia&gt; weights = [0.1667, 0.1667, 0.1667, 0.1667, 0.1667, 0.1667];

julia&gt; fns = [maximum, maximum, maximum, maximum, maximum, minimum];

julia&gt; result = copras(decmat, w, fs);

julia&gt; result.bestIndex
38

julia&gt; result.scores
38-element Array{Float64,1}:
 0.021727395411605937
 0.019814414550092637
 0.01789214190869233
 0.01624057709923278
 0.01507318798582843
 0.021837811311495522
 0.020735423365838293
 0.01754833367014725
 0.016658288043259514
 0.016258710042371068
 0.019388734250223458
 ⋮
 0.01064826476628102
 0.01000964101170639
 0.007056714858865703
 0.010627520153194962
 0.010419795157349462
 0.010212070161503961
 0.00876261130160425
 0.007733739643860005
 0.007258939653356005
 0.006665439665226005
 0.005478439688966004</code></pre><p><strong>References</strong></p><p>Kaklauskas, A., Zavadskas, E. K., Raslanas, S., Ginevicius, R., Komka, A., &amp; Malinauskas, P. (2006). Selection of low-e windows in retrofit of public buildings by applying multiple criteria method COPRAS: A Lithuanian case. Energy and buildings, 38(5), 454-462. Özdağoğlu, A. (2013). İmalat işletmeleri için eksantrik pres alternatiflerinin COPRAS yöntemi ile karşılaştırılması. Gümüşhane Üniversitesi Sosyal Bilimler Enstitüsü Elektronik Dergisi, 4(8), 1-22. Yıldırım, B. F., Timor, M. (2019). &quot;Bulanık ve Gri COPRAS Yöntemleri Kullanılarak Tedarikçi Seçim Modeli Geliştirilmesi&quot;. Optimum Ekonomi ve Yönetim Bilimleri Dergisi, 6 (2), 283-310.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/copras.jl#L28-L148">source</a></section><section><div><pre><code class="language-julia hljs">copras(setting)</code></pre><p>Apply COPRAS (COmplex PRoportional ASsesment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>copras() applies the COPRAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::COPRASResult</code>: COPRASResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/copras.jl#L200-L212">source</a></section></article><h2 id="PROMETHEE"><a class="docs-heading-anchor" href="#PROMETHEE">PROMETHEE</a><a id="PROMETHEE-1"></a><a class="docs-heading-anchor-permalink" href="#PROMETHEE" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.PROMETHEE.promethee" href="#JMcDM.PROMETHEE.promethee"><code>JMcDM.PROMETHEE.promethee</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    promethee(decisionMatrix, weights, fns, prefs, qs, ps)</code></pre><p>Apply PROMETHEE (Preference Ranking Organization METHod for Enrichment of Evaluations) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMatrix::Matrix</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions that are either maximum or minimum.</li><li><code>prefs::Array{Function, 1}</code>: m-vector of preference functions that are prometLinear, prometVShape, prometUShape, prometQuasi, or prometLevel.</li><li><code>qs::Array{Float64, 1}</code>: m-vector of q parameters that is used in corresponding preference function.</li><li><code>ps::Array{Float64, 1}</code>: m-vector of p parameters that is used in corresponding preference function</li></ul><p><strong>Description</strong></p><p>promethee() applies the PROMETHEE method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::PrometheeResult</code>: PrometheeResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [42.0 35 43 51; 
                     89 72 92 85;
                     14 85 17 40;
                     57 60 45 80;
                     48 32 43 40;
                     71 45 60 85;
                     69 40 72 55;
                     64 35 70 60];



julia&gt; qs = [49, nothing, 45, 30];

julia&gt; ps = [100, 98, 95, 80];

julia&gt; weights = [0.25, 0.35, 0.22, 0.18];

julia&gt; fns = [maximum, maximum, maximum, maximum];

julia&gt; prefs = [prometLinear, prometVShape, prometLinear, prometLinear];

julia&gt; result = promethee(decmat, weights, fns, prefs, qs, ps);

julia&gt; result.scores
8-element Array{Float64,1}:
  0.0698938775510204
 -0.148590956382553
 -0.061361984793917565
 -0.04780408163265306
  0.09859591836734694
 -0.0006389755902360891
  0.03236974789915966
  0.057536454581832736

julia&gt; result.bestIndex
5</code></pre><p><strong>References</strong></p><p>İşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/promethee.jl#L101-L164">source</a></section><section><div><pre><code class="language-julia hljs">    promethee(setting, prefs, qs, ps)</code></pre><p>Apply PROMETHEE (Preference Ranking Organization METHod for Enrichment of Evaluations) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li><li><code>prefs::Array{Function, 1}</code>: m-vector of preference functions that are prometLinear, prometVShape, prometUShape, prometQuasi, or prometLevel.</li><li><code>qs::Array{Float64, 1}</code>: m-vector of q parameters that is used in corresponding preference function.</li><li><code>ps::Array{Float64, 1}</code>: m-vector of p parameters that is used in corresponding preference function</li></ul><p><strong>Description</strong></p><p>promethee() applies the PROMETHEE method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::PrometheeResult</code>: PrometheeResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/promethee.jl#L207-L224">source</a></section></article><h2 id="CoCoSo"><a class="docs-heading-anchor" href="#CoCoSo">CoCoSo</a><a id="CoCoSo-1"></a><a class="docs-heading-anchor-permalink" href="#CoCoSo" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.COCOSO.cocoso" href="#JMcDM.COCOSO.cocoso"><code>JMcDM.COCOSO.cocoso</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    cocoso(decisionMat, weights, fns; lambda, normalization)</code></pre><p>Apply CoCoSo (Combined Compromise Solution) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns.</li><li><code>lambda::Float64</code>: joint criterion. 0&lt;=lambda&lt;=1, default=0.5.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>cocoso() applies the CoCoSo method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::CoCoSoResult</code>: CoCoSoResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [3        12.5        2        120        14        3;
       5        15        3        110        38        4;
       3        13        2        120        19        3;
       4        14        2        100        31        4;
       3        15        1.5        125        40        4]
5×6 Array{Float64,2}:
 3.0  12.5  2.0  120.0  14.0  3.0
 5.0  15.0  3.0  110.0  38.0  4.0
 3.0  13.0  2.0  120.0  19.0  3.0
 4.0  14.0  2.0  100.0  31.0  4.0
 3.0  15.0  1.5  125.0  40.0  4.0

julia&gt; weights = [0.221, 0.159, 0.175, 0.127, 0.117, 0.201];

julia&gt; fns = [maximum, minimum, minimum, maximum, minimum, maximum];

julia&gt; result = cocoso(decmat, weights, fns, lambda = 0.5);

julia&gt; result.scores
5-element Vector{Float64}:
 1.922475728710679
 1.8144169615649441
 1.8374089377955838
 2.1842047284481
 1.6232623861380282

julia&gt; result.bestIndex
4</code></pre><p><strong>References</strong></p><p>Yazdani, M., Zarate, P., Kazimieras Zavadskas, E. and Turskis, Z. (2019), &quot;A combined compromise solution (CoCoSo) method for multi-criteria decision-making problems&quot;, Management Decision, Vol. 57 No. 9, pp. 2501-2519. https://doi.org/10.1108/MD-05-2017-0458</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/cocoso.jl#L29-L83">source</a></section><section><div><pre><code class="language-julia hljs">    cocoso(setting; lambda)</code></pre><p>Apply CoCoSo (Combined Compromise Solution) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object </li><li><code>lambda::Float64</code>: joint criterion. 0&lt;=lambda&lt;=1, default=0.5.</li></ul><p><strong>Description</strong></p><p>cocoso() applies the CoCoSo method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::CoCoSoResult</code>: CoCoSoResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/cocoso.jl#L133-L148">source</a></section></article><h2 id="Critic"><a class="docs-heading-anchor" href="#Critic">Critic</a><a id="Critic-1"></a><a class="docs-heading-anchor-permalink" href="#Critic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.CRITIC.critic" href="#JMcDM.CRITIC.critic"><code>JMcDM.CRITIC.critic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    critic(decisionMat, fns; normalization)</code></pre><p>Apply CRITIC (Combined Compromise Solution) method for a given matrix and criteria types.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>critic() applies the CRITIC method to calculate weights using a decision matrix with   n alterntives subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::CRITICResult</code>: CRITICResult object that holds multiple outputs including weighting and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">
julia&gt; decmat
3×4 Array{Float64,2}:
 12.9918  0.7264  -1.1009  1.59814
  4.1201  5.8824   3.4483  1.02156
  4.1039  0.0     -0.5076  0.984469


julia&gt; fns = [maximum, maximum, minimum, maximum];

julia&gt; result = critic(decmat, fns);

julia&gt; result.w
4-element Array{Float64,1}:
 0.16883905506169491
 0.41844653698732126
 0.24912338769165807
 0.16359102025932576
</code></pre><p><strong>References</strong></p><p>Diakoulaki, D., Mavrotas, G., &amp; Papayannakis, L. (1995). Determining objective weights in multiple criteria problems: The critic method. Computers &amp; Operations Research, 22(7), 763–770. doi:10.1016/0305-0548(94)00059-h  Akçakanat, Ö., Aksoy, E., Teker, T. (2018). CRITIC ve MDL Temelli EDAS Yöntemi ile TR-61 Bölgesi Bankalarının Performans Değerlendirmesi. Süleyman Demirel Üniversitesi Sosyal Bilimler Enstitüsü Dergisi, 1 (32), 1-24.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/critic.jl#L27-L71">source</a></section><section><div><pre><code class="language-julia hljs">    critic(setting)</code></pre><p>Apply CRITIC (Combined Compromise Solution) method for a given matrix and criteria types.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>critic() applies the CRITIC method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::CRITICResult</code>: CRITICResult object that holds multiple outputs including weighting and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/critic.jl#L112-L126">source</a></section></article><h2 id="CODAS"><a class="docs-heading-anchor" href="#CODAS">CODAS</a><a id="CODAS-1"></a><a class="docs-heading-anchor-permalink" href="#CODAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.CODAS.codas" href="#JMcDM.CODAS.codas"><code>JMcDM.CODAS.codas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">codas(decisionMat, weights, fs; normalization)</code></pre><p>Apply CODAS (COmbinative Distance-based ASsessment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fs::Array{&lt;:Function,1}</code>: m-vector of type of criteria. The benefit criteria shown with &quot;maximum&quot;, and the cost criteria shown with &quot;minimum&quot;.</li><li><code>tau::Float64</code>: tau parameter for the algorithm. The default is 0.02.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>codas() applies the CODAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::CODASResult</code>: CODASResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat
7×5 Array{Float64,2}:
 60.0   0.4   2540.0   500.0   990.0
  6.35  0.15  1016.0  3000.0  1041.0
  6.8   0.1   1727.2  1500.0  1676.0
 10.0   0.2   1000.0  2000.0   965.0
  2.5   0.1    560.0   500.0   915.0
  4.5   0.08  1016.0   350.0   508.0
  3.0   0.1   1778.0  1000.0   920.0

julia&gt; df = DataFrame(decmat)
7×5 DataFrame
 Row │ x1       x2       x3       x4       x5      
     │ Float64  Float64  Float64  Float64  Float64 
─────┼─────────────────────────────────────────────
   1 │   60.0      0.4    2540.0    500.0    990.0
   2 │    6.35     0.15   1016.0   3000.0   1041.0
   3 │    6.8      0.1    1727.2   1500.0   1676.0
   4 │   10.0      0.2    1000.0   2000.0    965.0
   5 │    2.5      0.1     560.0    500.0    915.0
   6 │    4.5      0.08   1016.0    350.0    508.0
   7 │    3.0      0.1    1778.0   1000.0    920.0

julia&gt; result = codas(Matrix(df), w, fs);
julia&gt; result.bestIndex
2
julia&gt; result.scores
7-element Array{Float64,1}:
  0.5121764914884954
  1.463300034504913
  1.0715325899642418
 -0.21246799780012637
 -1.8515205523193041
 -1.1716767695713806
  0.18865620373316055
</code></pre><p><strong>References</strong></p><p>Keshavarz Ghorabaee, M., Zavadskas, E. K., Turskis, Z., &amp; Antucheviciene, J. (2016). A new combinative distance-based assessment (CODAS) method for multi-criteria decision-making. Economic Computation &amp; Economic Cybernetics Studies &amp; Research, 50(3), 25-44.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/codas.jl#L31-L89">source</a></section><section><div><pre><code class="language-julia hljs">codas(setting; tau = 0.02)</code></pre><p>Apply CODAS (COmbinative Distance-based ASsessment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li><li><code>tau::Float64</code>: tau parameter for the algorithm. The default is 0.02.</li></ul><p><strong>Description</strong></p><p>codas() applies the CODAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::CODASResult</code>: CODASResult object that holds multiple outputs including scores and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/codas.jl#L167-L181">source</a></section></article><h2 id="MEREC"><a class="docs-heading-anchor" href="#MEREC">MEREC</a><a id="MEREC-1"></a><a class="docs-heading-anchor-permalink" href="#MEREC" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.MEREC.merec" href="#JMcDM.MEREC.merec"><code>JMcDM.MEREC.merec</code></a> — <span class="docstring-category">Function</span></header><section><div><p>merec(decisionMat, fns; normalization)</p><p>Apply MEREC (MEthod based on the Removal Effects of Criteria) for a given matrix and criteria types.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>merec() applies the MEREC method to calculate weights using a decision matrix with   n alternatives subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MERECResult</code>: MERECResult object that holds multiple outputs including weights.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">
julia&gt; decisionMat = DataFrame(
                   :K1 =&gt; [450, 10, 100, 220, 5],
                   :K2 =&gt; [8000, 9100, 8200, 9300, 8400],
                   :K3 =&gt; [54, 2, 31, 1, 23],
                   :K4 =&gt; [145, 160, 153, 162, 158]
               )
5×4 DataFrame
 Row │ K1     K2     K3     K4    
     │ Int64  Int64  Int64  Int64 
─────┼────────────────────────────
   1 │   450   8000     54    145
   2 │    10   9100      2    160
   3 │   100   8200     31    153
   4 │   220   9300      1    162
   5 │     5   8400     23    158

julia&gt; fs = [maximum, maximum, minimum, minimum];

julia&gt; result = merec(decisionMat, fs);

julia&gt; result.w
4-element Vector{Float64}:
 0.5752216672093823
 0.01409659116846726
 0.40156136388773117
 0.009120377734419302
</code></pre><p><strong>References</strong></p><p>Keshavarz-Ghorabaee, M., Amiri, M., Zavadskas, E. K., Turskis, Z., &amp; Antucheviciene, J. (2021). Determination of Objective Weights Using a New Method Based on the Removal Effects of Criteria (MEREC). Symmetry, 13(4), 525. https://doi.org/10.3390/sym13040525</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/merec.jl#L26-L78">source</a></section><section><div><pre><code class="language-julia hljs">    merec(setting)</code></pre><p>Apply MEREC (MEthod based on the Removal Effects of Criteria) for a given matrix and criteria types.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>merec() applies the MEREC method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MERECResult</code>: MERECResult object that holds multiple outputs including weighting and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/merec.jl#L141-L155">source</a></section></article><h2 id="PIV"><a class="docs-heading-anchor" href="#PIV">PIV</a><a id="PIV-1"></a><a class="docs-heading-anchor-permalink" href="#PIV" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.PIV.piv" href="#JMcDM.PIV.piv"><code>JMcDM.PIV.piv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">piv(decisionMat, weights, fs; normalization)</code></pre><p>Apply PIV (Proximity Indexed Value) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fs::Array{&lt;:Function,1}</code>: m-vector of type of criteria. The benefit criteria shown with &quot;maximum&quot;, and the cost criteria shown with &quot;minimum&quot;.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>piv() applies the PIV method to rank n alternatives subject to m criteria and criteria type vector. Alternatives  with lesser scores values (u_i values in the original article) are better as they represent the deviation  from the ideal values.</p><p><strong>Output</strong></p><ul><li><code>::PIVResult</code>: PIVResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>References</strong></p><p>Sameera Mufazzal, S.M. Muzakkir, A new multi-criterion decision making (MCDM) method based on proximity indexed value for minimizing rank reversals, Computers &amp; Industrial Engineering, Volume 119, 2018, Pages 427-438, ISSN 0360-8352, https://doi.org/10.1016/j.cie.2018.03.045.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/piv.jl#L29-L52">source</a></section></article><h2 id="PSI"><a class="docs-heading-anchor" href="#PSI">PSI</a><a id="PSI-1"></a><a class="docs-heading-anchor-permalink" href="#PSI" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.PSI.psi" href="#JMcDM.PSI.psi"><code>JMcDM.PSI.psi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    psi(decisionMat, fns; normalization)</code></pre><p>Apply PSI (Preference Selection Index) method for a given matrix and directions of optimizations.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alterntives and m criteria </li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>psi() applies the PSI method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::PSIResult</code>: PSIResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [3        12.5        2        120        14        3;
       5        15        3        110        38        4;
       3        13        2        120        19        3;
       4        14        2        100        31        4;
       3        15        1.5        125        40        4]
5×6 Array{Float64,2}:
 3.0  12.5  2.0  120.0  14.0  3.0
 5.0  15.0  3.0  110.0  38.0  4.0
 3.0  13.0  2.0  120.0  19.0  3.0
 4.0  14.0  2.0  100.0  31.0  4.0
 3.0  15.0  1.5  125.0  40.0  4.0



julia&gt; fns = [maximum, minimum, minimum, maximum, minimum, maximum];

julia&gt; result = psi(decmat, fns)
Scores:
[1.1252480520930113, 0.762593438114615, 1.1060476892230147, 1.0059872302387025, 0.7865885089329105]
Ordering: (from worst to best)
[2, 5, 4, 3, 1]
Best indices:
1

julia&gt; result.bestIndex 
1</code></pre><p><strong>References</strong></p><p>Maniya, Kalpesh, and Mangal Guido Bhatt. &quot;A selection of material using a novel type decision-making method:  Preference selection index method.&quot; Materials &amp; Design 31.4 (2010): 1785-1789</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/psi.jl#L29-L79">source</a></section><section><div><pre><code class="language-julia hljs">    psi(setting)</code></pre><p>Apply PSI (Preference Selection Index) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>psi() applies the PSI method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::PSIResult</code>: PSIResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/psi.jl#L135-L149">source</a></section></article><h2 id="ROV"><a class="docs-heading-anchor" href="#ROV">ROV</a><a id="ROV-1"></a><a class="docs-heading-anchor-permalink" href="#ROV" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.ROV.rov" href="#JMcDM.ROV.rov"><code>JMcDM.ROV.rov</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    rov(decisionMat, weights, fns; normalization)</code></pre><p>Apply ROV (Range of Value) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns (directions of optimization). </li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>rov() applies the ROV method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::ROVResult</code>: ROVResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = [
        0.035 34.5 847 1.76 0.335 0.5 0.59 0.59
        0.027 36.8 834 1.68 0.335 0.665 0.665 0.665
        0.037 38.6 808 2.4 0.59 0.59 0.41 0.5
        0.028 32.6 821 1.59 0.5 0.59 0.59 0.41];


julia&gt;  w = [0.3306, 0.0718, 0.1808, 0.0718, 0.0459, 0.126, 0.126, 0.0472];

julia&gt; fns = [minimum, minimum, minimum, minimum, maximum, minimum, minimum, maximum]

julia&gt; result = rov(mat, w, fns)

julia&gt; result.ranks 

julia&gt; result.scores</code></pre><p><strong>References</strong></p><p>Madić, Miloš et al. “Application of the ROV method for the selection of cutting fluids.”  Decision Science Letters 5 (2016): 245-254.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/rov.jl#L28-L69">source</a></section></article><h2 id="MOOSRA"><a class="docs-heading-anchor" href="#MOOSRA">MOOSRA</a><a id="MOOSRA-1"></a><a class="docs-heading-anchor-permalink" href="#MOOSRA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.MOOSRA.moosra" href="#JMcDM.MOOSRA.moosra"><code>JMcDM.MOOSRA.moosra</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    moosra(decisionMat, weights, fns; lambda = 0.5, normalization)</code></pre><p>Apply MOOSRA (Multi-Objective Optimization on the basis of Simple Ratio Analysis) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alterntives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>moosra() applies the MOOSRA method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MoosraResult</code>: MoosraResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decmat = [3        12.5        2        120        14        3;
       5        15        3        110        38        4;
       3        13        2        120        19        3;
       4        14        2        100        31        4;
       3        15        1.5        125        40        4]
5×6 Array{Float64,2}:
 3.0  12.5  2.0  120.0  14.0  3.0
 5.0  15.0  3.0  110.0  38.0  4.0
 3.0  13.0  2.0  120.0  19.0  3.0
 4.0  14.0  2.0  100.0  31.0  4.0
 3.0  15.0  1.5  125.0  40.0  4.0


julia&gt; weights = [0.221, 0.159, 0.175, 0.127, 0.117, 0.201];

julia&gt; fns = [maximum, minimum, minimum, maximum, minimum, maximum];

julia&gt; result = moosra(decmat, weights, fns, lambda);</code></pre><p><strong>References</strong></p><p>Das, Manik Chandra, Bijan Sarkar, and Siddhartha Ray. &quot;Decision making under conflicting environment: a new MCDM method.&quot;  International Journal of Applied Decision Sciences 5.2 (2012): 142-162.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/moosra.jl#L26-L70">source</a></section><section><div><pre><code class="language-julia hljs">    moosra(setting)</code></pre><p>Apply MOOSRA (Multi-Objective Optimization on the basis of Simple Ratio Analysis) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/moosra.jl#L125-L132">source</a></section></article><h2 id="SD"><a class="docs-heading-anchor" href="#SD">SD</a><a id="SD-1"></a><a class="docs-heading-anchor-permalink" href="#SD" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.SD.sd" href="#JMcDM.SD.sd"><code>JMcDM.SD.sd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    sd(decisionMat, fns; normalization)</code></pre><p>Apply SD method for a given matrix and directions of optimization.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>sd() applies the SD method to calculate weights for a set of given criteria.</p><p><strong>Output</strong></p><ul><li><code>::SDResult</code>: SDResult object that holds weights.</li></ul><p><strong>References</strong></p><p>AYDIN, Yüksel. &quot;A hybrid multi-criteria decision making (MCDM) model consisting of SD and  COPRAS methods in performance evaluation of foreign deposit banks.&quot; Equinox Journal of  Economics Business and Political Studies 7.2 (2020): 160-176.</p><p>Diakoulaki, Danae, George Mavrotas, and Lefteris Papayannakis. &quot;Determining objective weights  in multiple criteria problems: The critic method.&quot; Computers &amp; Operations Research 22.7  (1995): 763-770.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/sd.jl#L21-L45">source</a></section><section><div><pre><code class="language-julia hljs">    sd(setting)</code></pre><p>Apply SD method for a given matrix and criteria types.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/sd.jl#L73-L80">source</a></section></article><h2 id="SECA"><a class="docs-heading-anchor" href="#SECA">SECA</a><a id="SECA-1"></a><a class="docs-heading-anchor-permalink" href="#SECA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.SECA.seca" href="#JMcDM.SECA.seca"><code>JMcDM.SECA.seca</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">seca(decisionMat, fns:, beta; epsilon, normalization)</code></pre><p>Implement the SECA method for multi-criteria decision making.</p><p><strong>Arguments</strong></p><ul><li><code>decisionMat::Matrix</code>: A matrix of decision criteria.</li><li><code>fns::Array{F,1}</code>: A vector of functions that specifies the Beneficial Criteria (BC) as <code>maximum</code> and the non-Beneficial Criteria (NC) as <code>minimum</code>.</li><li><code>beta::Float64</code>: This coefficient affects the importance of reaching the reference points of criteria weights. Note that the output of model is dependent on the value of beta. It&#39;s recommended to try several values untill you barely see any change in the weights of each criterion.</li><li><code>epsilon::Float64 = 10^-3</code>: a small positive parameter considered as a lower bound for criteria weights.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>seca implements the SECA method for multi-criteria decision making and finds the weights of the criteria simultaneously with evaluating the alternatives. The model is based on maximization of the overall performance of alternatives with consideration of the variation information of decision-matrix within and between criteria. seca returns a <code>SecaResult</code> object that contains the decision matrix, weights, scores, and ranks.</p><p><strong>Returns</strong></p><ul><li><code>SECAResult</code>: A <code>SECAResult</code> object that contains the decision matrix, weights, scores, and ranks.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using JuMP, Ipopt, JMcDM
julia&gt; mat = [
           1.0     0.9925  0.9115  0.8     0.9401  1.0     0.9449;
           0.8696  0.8271  0.8462  1.0     0.9181  0.978   1.0;
           0.7391  0.8684  0.7615  0.2667  0.8177  0.8241  0.8305;
           0.5217  0.7895  0.6654  0.2     0.8051  0.7236  0.8061;
           0.6522  0.9135  0.7692  0.2857  0.8396  0.7063  0.8812;
           0.6087  0.8346  0.7269  0.3077  0.8722  0.6742  0.8926;
           0.913   0.985   0.9346  0.6667  0.9813  0.8641  0.9216;
           0.8696  0.9624  1.0     0.5714  0.9632  0.7807  0.9751;
           0.8261  1.0     0.8077  0.6667  1.0     0.7946  0.9104;
           0.3478  0.8195  0.7462  0.3636  0.8263  0.6642  0.814
       ];

julia&gt; fns = [maximum, minimum, minimum, minimum, minimum, minimum, minimum];

julia&gt; seca(mat, fns, 0.5)
Scores:
[0.5495915719484191, 0.467758585220479, 0.7430581528101969, 0.805136683615562, 0.6786410609782462, 0.6314963009852793, 0.5445938440469921, 0.5570359821894877, 0.509907132860776, 0.4677585801615632]
Ordering:
[6, 9, 2, 1, 3, 4, 7, 5, 8, 10]
Best indice:
4</code></pre><p><strong>Reference</strong></p><ul><li><a href="http://dx.doi.org/10.15388/Informatica.2018.167">Simultaneous Evaluation of Criteria and Alternatives (SECA) for Multi-Criteria Decision-Making</a></li></ul><div class="admonition is-warning"><header class="admonition-header">Dependencies</header><div class="admonition-body"><p>This method is enabled when the JuMP and Ipopt packages are installed and loaded.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/seca.jl#L28-L83">source</a></section></article><h2 id="LMAW"><a class="docs-heading-anchor" href="#LMAW">LMAW</a><a id="LMAW-1"></a><a class="docs-heading-anchor-permalink" href="#LMAW" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.LMAW.lmaw" href="#JMcDM.LMAW.lmaw"><code>JMcDM.LMAW.lmaw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lmaw(decisionMat, weights, fns; normalization)</code></pre><p>Apply LMAW (Logarithm Methodology of Additive Weights) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: m × n matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: n-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: n-vector of functions to be applied on the columns.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>lmaw() applies the LMAW method to rank m alternatives subject to n criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::LMAWResult</code>: LMAWResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decMat = [
                647.34        6.24        49.87        19.46        212.58        6.75;
                115.64        3.24        16.26         9.69        207.59        3.00;
                373.61        5.00        26.43        12.00        184.62        3.74;
                 37.63        2.48         2.85         9.25        142.50        3.24;
                858.01        4.74        62.85        45.96        267.95        4.00;
                222.92        3.00        19.24        21.46        221.38        3.49
                ]   
       6×6 Matrix{Float64}:
       647.34  6.24  49.87  19.46  212.58  6.75
       115.64  3.24  16.26   9.69  207.59  3.0
       373.61  5.0   26.43  12.0   184.62  3.74
        37.63  2.48   2.85   9.25  142.5   3.24
       858.01  4.74  62.85  45.96  267.95  4.0
       222.92  3.0   19.24  21.46  221.38  3.49

julia&gt; weights = [0.215, 0.126, 0.152, 0.091, 0.19, 0.226];

julia&gt; fns = [maximum, maximum, minimum, minimum, minimum, maximum];

julia&gt; result = lmaw(decmat, weights, fns);

julia&gt; result.scores
6-element Vector{Float64}:
 4.839005264308832
 4.679718180594332
 4.797731427991642
 4.732145373983716
 4.73416833375772
 4.702247270959649

julia&gt; result.bestIndex
1</code></pre><p><strong>References</strong></p><ul><li>Pamučar, D., Žižović, M., Biswas, S., &amp; Božanić, D. (2021). A new logarithm methodology of additive weights (LMAW) for multi-criteria decision-making: Application in logistics. Facta Universitatis, Series: Mechanical Engineering, 19(3), 361. https://doi.org/10.22190/FUME210214031P</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/lmaw.jl#L25-L84">source</a></section><section><div><pre><code class="language-julia hljs">lmaw(setting)</code></pre><p>Apply LMAW (Logarithm Methodology of Additive Weights) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>lmaw() applies the LMAW method to rank m alternatives subject to n criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::LMAWResult</code>: LMAWResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/lmaw.jl#L121-L135">source</a></section></article><h2 id="LOPCOW"><a class="docs-heading-anchor" href="#LOPCOW">LOPCOW</a><a id="LOPCOW-1"></a><a class="docs-heading-anchor-permalink" href="#LOPCOW" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.LOPCOW.lopcow" href="#JMcDM.LOPCOW.lopcow"><code>JMcDM.LOPCOW.lopcow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lopcow(decisionMat, fns; normalization)</code></pre><p>Apply LOPCOW (LOgarithmic Percentage Change-driven Objective Weighting) method for a given matrix and criteria types.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>fns::Array{&lt;:Function, 1}</code>: m-vector of functions to be applied on the columns.</li><li><code>normalization{&lt;:Function}</code>: Optional normalization function.</li></ul><p><strong>Description</strong></p><p>lopcow() applies the LOPCOW method to calculate objective weights using a decision matrix with   n alterntives subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::LOPCOWResult</code>: LOPCOWResult object that holds multiple outputs including weighting and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">
julia&gt; decmat
9×17 Matrix{Float64}:
 21.8  14.1  10.7  1.6  1.8   770.0  12750.0  18.0   5100.0  1.5     9.1    1.054  4.196  29.407   7.03   15.08    9.705
 16.4   8.5  13.9  1.2  1.3   524.0  12087.0   5.7   2941.0  2.208  15.2    1.123  3.86    5.228  14.724  32.103  19.0
 14.5   7.0   2.3  0.2  0.2   238.0   3265.0   1.9    320.0  2.32   16.202  1.008  3.095   5.549  17.34   65.129  32.056
 18.2  10.3  11.4  1.2  1.1   835.0  16037.0  21.3   4332.0  0.875   9.484  0.856  2.191  23.75   13.1    58.157  27.46
 18.5   8.1  11.1  1.0  1.1   504.0   9464.0   1.4   1743.0  2.95    0.7    0.479  2.44    8.77   13.48   33.45   17.68
 18.7  11.4  10.8  1.3  1.5  1227.0  24053.0  20.0   6521.0  0.733   1.6    0.857  2.377   4.985  11.743  26.732  24.485
 18.5  12.6  10.8  1.4  1.8   912.0  18800.0  18.2   5300.0  1.29    8.27   0.558  0.635   5.22   13.829  31.914   7.515
 16.4   6.7  12.6  0.9  0.9   951.0  16767.0  22.0   3917.0  2.46    3.9    0.724  0.568   4.491  14.357  28.869   7.313
 15.2   6.3   6.9  0.5  0.5  1013.0  20170.0  10.97  4060.0  1.67    1.7    0.704  2.96    3.24   10.029  60.981  23.541

julia&gt; fns = [maximum, maximum, maximum, maximum, maximum, maximum, maximum, maximum, maximum, maximum, minimum, minimum, minimum, minimum, minimum, minimum, minimum ];

julia&gt; result = lopcow(decmat, fns);

julia&gt; result.w
17-element Vector{Float64}:
 0.04947396185854988
 0.036623078374935315
 0.08456624432002027
 0.07055941647198624
 ⋮
 0.07625360895444118
 0.05507171491276535
 0.05320727577078255
 0.05340460620185558
</code></pre><p><strong>References</strong></p><p>Ecer, F., &amp; Pamucar, D. (2022). A novel LOPCOW‐DOBI multi‐criteria sustainability performance assessment methodology: An application in developing country banking sector. Omega, 112, 102690. https://doi.org/10.1016/j.omega.2022.102690</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/lopcow.jl#L22-L75">source</a></section><section><div><pre><code class="language-julia hljs">lopcow(setting)</code></pre><p>Apply LOPCOW (LOgarithmic Percentage Change-driven Objective Weighting) method for a given matrix and criteria types.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>lopcow() applies the LOPCOW method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::LOPCOWResult</code>: LOPCOWResult object that holds multiple outputs including weighting and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/lopcow.jl#L109-L123">source</a></section></article><h2 id="OCRA"><a class="docs-heading-anchor" href="#OCRA">OCRA</a><a id="OCRA-1"></a><a class="docs-heading-anchor-permalink" href="#OCRA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.OCRA.ocra" href="#JMcDM.OCRA.ocra"><code>JMcDM.OCRA.ocra</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ocra(decisionMat, weights, fns)</code></pre><p>Apply OCRA (Operational Competitiveness RAting) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Matrix</code>: m × n matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: n-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{&lt;:Function, 1}</code>: n-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>ocra() applies the OCRA method to rank m alternatives subject to n criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::OCRAResult</code>: OCRAResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decMat = [
            8.0  16.0  1.5  1.2   4200.0  5.0  5.0  314.0  185.0;
            8.0  16.0  1.0  1.3   4200.0  5.0  4.0  360.0  156.0;
           10.1  16.0  2.0  1.3   4060.0  5.0  3.0  503.0  160.0;
           10.1   8.0  1.0  1.5   5070.0  2.0  4.0  525.0  200.0;
           10.0  16.0  2.0  1.2   6350.0  5.0  3.0  560.0  190.0;
           10.1  16.0  1.0  1.2   5500.0  2.0  2.0  521.0  159.0;
           10.1  64.0  2.0  1.7   5240.0  5.0  3.0  770.0  199.0;
            7.0  32.0  1.0  1.8   3000.0  3.0  4.0  364.0  157.0;
           10.1  16.0  1.0  1.3   3540.0  5.0  3.0  510.0  171.0;
            9.7  16.0  2.0  1.83  7500.0  6.0  2.0  550.0  170.0
       ]
10×9 Matrix{Float64}:
  8.0  16.0  1.5  1.2   4200.0  5.0  5.0  314.0  185.0
  8.0  16.0  1.0  1.3   4200.0  5.0  4.0  360.0  156.0
 10.1  16.0  2.0  1.3   4060.0  5.0  3.0  503.0  160.0
 10.1   8.0  1.0  1.5   5070.0  2.0  4.0  525.0  200.0
 10.0  16.0  2.0  1.2   6350.0  5.0  3.0  560.0  190.0
 10.1  16.0  1.0  1.2   5500.0  2.0  2.0  521.0  159.0
 10.1  64.0  2.0  1.7   5240.0  5.0  3.0  770.0  199.0
  7.0  32.0  1.0  1.8   3000.0  3.0  4.0  364.0  157.0
 10.1  16.0  1.0  1.3   3540.0  5.0  3.0  510.0  171.0
  9.7  16.0  2.0  1.83  7500.0  6.0  2.0  550.0  170.0

julia&gt; weights =[0.167, 0.039, 0.247, 0.247, 0.116, 0.02, 0.056, 0.027, 0.081];

julia&gt; fns = [maximum,maximum,maximum,maximum,maximum,maximum,maximum,minimum,minimum];

julia&gt; result = ocra(decmat, weights, fns);

julia&gt; result.scores
10-element Vector{Float64}:
 0.14392093908214929
 0.024106550710436096
 0.27342011595623067
 0.04297916544177691
 0.31851953804157623
 0.0024882426914910674
 0.5921715172301161
 0.11390289470614312
 0.0
 0.47874854984718046

julia&gt; result.bestIndex
7</code></pre><p><strong>References</strong></p><ul><li>Parkan, C. (1994). Operational competitiveness ratings of production units. Managerial and Decision Economics, 15(3), 201–221. doi:10.1002/mde.4090150303 </li><li>Parkan, C. (2003). Measuring the effect of a new point of sale system on the performance of drugstore operations. Computers &amp; Operations Research, 30(5), 729–744. doi:10.1016/s0305-0548(02)00047-3 </li><li>Kundakcı, N. (2017). An Integrated Multi-Criteria Decision Making Approach for Tablet Computer Selection. European Journal of Multidisciplinary Studies, 2(5), 31-43.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/ocra.jl#L19-L90">source</a></section><section><div><pre><code class="language-julia hljs">ocra(setting)</code></pre><p>Apply OCRA (Operational Competitiveness RAting) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>setting::MCDMSetting</code>: MCDMSetting object. </li></ul><p><strong>Description</strong></p><p>ocra() applies the OCRA method to rank m alternatives subject to n criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::OCRAResult</code>: OCRAResult object that holds multiple outputs including scores, rankings, and best index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/ocra.jl#L133-L147">source</a></section></article><h2 id="TODIM"><a class="docs-heading-anchor" href="#TODIM">TODIM</a><a id="TODIM-1"></a><a class="docs-heading-anchor-permalink" href="#TODIM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMcDM.TODIM.todim" href="#JMcDM.TODIM.todim"><code>JMcDM.TODIM.todim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">todim(decisionMat::Matrix, weights::Vector, fns::Array{F,1})::TODIMResult where F&lt;:Function</code></pre><p>Run TODIM method for a given desicion matrix, criteria weights and identity of criteria.</p><p><strong>Arguments</strong></p><ul><li><code>decisionMat::Matrix</code>: A matrix of decision criteria. It&#39;s assumed that the criteria are </li></ul><p>in the columns and alternatives are in the rows.</p><ul><li><code>weights::Vector</code>: A vector of weights of criteria.</li><li><code>fns::Array{F,1}</code>: A vector of functions that specifies the Beneficial Criteria (BC) as </li></ul><p><code>maximum</code> and the non-Beneficial Criteria (NC) as <code>minimum</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>normalization{&lt;:Function}</code>: Optional normalization function. Default is min-max  normalization (available as <code>Normalizations.maxminrangenormalization</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>TODIMResult</code>: A TODIMResult object that holds multiple outputs including scores and best </li></ul><p>index.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; mat = [
           1.0     0.9925;
           0.8696  0.8271;
           0.7391  0.8684;
           0.5217  0.7895;
           0.6522  0.9135;
           0.6087  0.8346;
           0.913   0.185
       ];

julia&gt; fns = [maximum, minimum];

julia&gt; w = [2, 3];

julia&gt; result = todim(mat, w, fns)
TODIMResult([1.0 0.9925; 0.8696 0.8271; … ; 0.6087 0.8346; 0.913 0.185], [2.0, 3.0], [1.0, 0.4285714285714285, 0.5952380952380951, 0.0, 0.5714285714285714, 0.30952380952380953, 0.3095238095238094], [1, 3, 5, 2, 6, 7, 4], 1)</code></pre><p><strong>References</strong></p><ol><li><p>Gomes, L. F. A. M., &amp; Lima, M. M. P. P. (1991). TODIMI: Basics and application to multicriteria ranking. Found. Comput. Decis. Sci, 16(3-4), 1-16.</p></li><li><p>Alali, F., &amp; Tolga, A. C. (2019). Portfolio allocation with the TODIM method. Expert Systems with Applications, 124, 341-348.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/5d6b19fcb4575354ec389322a92bfb2cd4a8234d/src/todim.jl#L186-L230">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="../normalizations/">Normalization Methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Sunday 14 April 2024 06:28">Sunday 14 April 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
